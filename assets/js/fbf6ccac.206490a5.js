"use strict";(self.webpackChunkrust_book_abridged=self.webpackChunkrust_book_abridged||[]).push([[1380],{3905:(e,t,r)=>{r.d(t,{Zo:()=>p,kt:()=>h});var a=r(7294);function n(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,a)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){n(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function c(e,t){if(null==e)return{};var r,a,n=function(e,t){if(null==e)return{};var r,a,n={},o=Object.keys(e);for(a=0;a<o.length;a++)r=o[a],t.indexOf(r)>=0||(n[r]=e[r]);return n}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)r=o[a],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(n[r]=e[r])}return n}var l=a.createContext({}),s=function(e){var t=a.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},p=function(e){var t=s(e.components);return a.createElement(l.Provider,{value:t},e.children)},m="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var r=e.components,n=e.mdxType,o=e.originalType,l=e.parentName,p=c(e,["components","mdxType","originalType","parentName"]),m=s(r),d=n,h=m["".concat(l,".").concat(d)]||m[d]||u[d]||o;return r?a.createElement(h,i(i({ref:t},p),{},{components:r})):a.createElement(h,i({ref:t},p))}));function h(e,t){var r=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var o=r.length,i=new Array(o);i[0]=d;var c={};for(var l in t)hasOwnProperty.call(t,l)&&(c[l]=t[l]);c.originalType=e,c[m]="string"==typeof e?e:n,i[1]=c;for(var s=2;s<o;s++)i[s]=r[s];return a.createElement.apply(null,i)}return a.createElement.apply(null,r)}d.displayName="MDXCreateElement"},3517:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>c,toc:()=>s});var a=r(7462),n=(r(7294),r(3905));const o={},i="19.5 - Macros",c={unversionedId:"ch19/ch19-05-macros",id:"ch19/ch19-05-macros",title:"19.5 - Macros",description:"If you're coming to Rust from C or C++, then you're no doubt already familiar with macros. We're going to give a quick introduction to macros here, but if you want to read more you should check out The Little Book of Rust Macros.",source:"@site/docs/ch19/ch19-05-macros.md",sourceDirName:"ch19",slug:"/ch19/ch19-05-macros",permalink:"/ch19/ch19-05-macros",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/ch19/ch19-05-macros.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"19.4 - Advanced Functions and Closures",permalink:"/ch19/ch19-04-advanced-functions-and-closures"},next:{title:"20 - Multithreaded Web Server",permalink:"/category/20---multithreaded-web-server"}},l={},s=[{value:"Declarative Macros with <code>macro_rules!</code> for General Metaprogramming",id:"declarative-macros-with-macro_rules-for-general-metaprogramming",level:2},{value:"Procedural Macros for Generating Code from Attributes",id:"procedural-macros-for-generating-code-from-attributes",level:2}],p={toc:s},m="wrapper";function u(e){let{components:t,...r}=e;return(0,n.kt)(m,(0,a.Z)({},p,r,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"195---macros"},"19.5 - Macros"),(0,n.kt)("p",null,"If you're coming to Rust from C or C++, then you're no doubt already familiar with macros. We're going to give a quick introduction to macros here, but if you want to read more you should check out ",(0,n.kt)("a",{parentName:"p",href:"https://veykril.github.io/tlborm/introduction.html"},"The Little Book of Rust Macros"),"."),(0,n.kt)("p",null,'Macros are a kind of "metaprogramming". When we write a Macro, we\'re actually writing Rust code that generates more Rust code.'),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Macros run at compile time, so they have no runtime performance impact (although they can generate code that runs at runtime, which might)."),(0,n.kt)("li",{parentName:"ul"},"Macros can take a variable number of parameters (such as the ",(0,n.kt)("inlineCode",{parentName:"li"},"println!")," marco does) which normal Rust functions cannot."),(0,n.kt)("li",{parentName:"ul"},"Macros must be brought into scope or defined before they are called.")),(0,n.kt)("h2",{id:"declarative-macros-with-macro_rules-for-general-metaprogramming"},"Declarative Macros with ",(0,n.kt)("inlineCode",{parentName:"h2"},"macro_rules!")," for General Metaprogramming"),(0,n.kt)("p",null,(0,n.kt)("em",{parentName:"p"},"Declarative macros"),' are sometimes called "macros by example" or just "macros" (because these are the most common kind of macro you\'re going to encounter). Here is a very simple macro:'),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-rust"},'macro_rules! four {\n    () => {\n        1 + 3\n    };\n}\n\nfn main() {\n    let x = four!();\n    println!("{x}");\n}\n\n')),(0,n.kt)("p",null,"The ",(0,n.kt)("inlineCode",{parentName:"p"},"macro_rules! four")," says we're going to declare a macro named ",(0,n.kt)("inlineCode",{parentName:"p"},"four!"),". Inside the ",(0,n.kt)("inlineCode",{parentName:"p"},"{}"),", the rest of this macro is a little similar to a ",(0,n.kt)("inlineCode",{parentName:"p"},"match")," expression. Each rule in a ",(0,n.kt)("inlineCode",{parentName:"p"},"macro_rules!")," is of the format ",(0,n.kt)("inlineCode",{parentName:"p"},"(MATCHER) => {EXPANSION};"),". When we call a macro, we don't actually pass in parameters like ",(0,n.kt)("inlineCode",{parentName:"p"},"i32"),"s or ",(0,n.kt)("inlineCode",{parentName:"p"},"&str"),"s, instead we're passing in a snippet of Rust code. When the macro runs, it will try to match the passed in token tree to each matcher in turn. Once it finds a match, we'll replace the whole macro with whatever is in the expansion part."),(0,n.kt)("p",null,'In the case of our macro above, we just have a single "empty matcher". If you were to try calling ',(0,n.kt)("inlineCode",{parentName:"p"},'let x = four!("hello");'),", you'd get an error telling you ",(0,n.kt)("inlineCode",{parentName:"p"},'no rules expected the token `"hello"`'),"."),(0,n.kt)("p",null,"A matcher can contain ",(0,n.kt)("em",{parentName:"p"},"captures")," which let us capture some tokens to a ",(0,n.kt)("em",{parentName:"p"},"metavariable"),". Metavariables start with ",(0,n.kt)("inlineCode",{parentName:"p"},"$"),":"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-rust"},"macro_rules! add_one {\n    ($e:expr) => { $e + 1 };\n}\n")),(0,n.kt)("p",null,"Here if you called ",(0,n.kt)("inlineCode",{parentName:"p"},"add_one!(2)")," would be replaced with ",(0,n.kt)("inlineCode",{parentName:"p"},"2 + 1"),". Let's have a look at the ",(0,n.kt)("inlineCode",{parentName:"p"},"vec!")," macro, which is a bit more exciting:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-rust"},"#[macro_export]\nmacro_rules! vec {\n    ( $( $x:expr ),* ) => {\n        {\n            let mut temp_vec = Vec::new();\n            $(\n                temp_vec.push($x);\n            )*\n            temp_vec\n        }\n    };\n}\n")),(0,n.kt)("admonition",{type:"note"},(0,n.kt)("p",{parentName:"admonition"},"This is actually a slightly simplified version of ",(0,n.kt)("inlineCode",{parentName:"p"},"vec!"),", because the original tries to preallocate the correct amount of data in the new vector, and this would only serve to make this example even more confusing than it already is.")),(0,n.kt)("p",null,"First, notice we've added the ",(0,n.kt)("inlineCode",{parentName:"p"},"#[macro_export]")," annotation. Without this annotation, this macro can't be used outside of the crate it is defined in."),(0,n.kt)("p",null,"The ",(0,n.kt)("inlineCode",{parentName:"p"},"$(),*")," part of the matcher here is called a ",(0,n.kt)("em",{parentName:"p"},"repetition"),". These have the form ",(0,n.kt)("inlineCode",{parentName:"p"},"$ (...) sep rep"),", where ",(0,n.kt)("inlineCode",{parentName:"p"},"( ... )")," is the part that's being repeated, ",(0,n.kt)("inlineCode",{parentName:"p"},"sep")," is an optional separator token, and ",(0,n.kt)("inlineCode",{parentName:"p"},"rep")," defines how many times the pattern can repeat - ",(0,n.kt)("inlineCode",{parentName:"p"},"?")," for zero or one, ",(0,n.kt)("inlineCode",{parentName:"p"},"*")," for zero or more, and ",(0,n.kt)("inlineCode",{parentName:"p"},"+")," for one or more (like in a regular expression)."),(0,n.kt)("p",null,"So ",(0,n.kt)("inlineCode",{parentName:"p"},"( $( $x:expr ),* )")," matches zero or more expressions, separated by commas."),(0,n.kt)("p",null,"On the right hand side of the ",(0,n.kt)("inlineCode",{parentName:"p"},"=>")," we have the code we're going to expand this to. Inside the ",(0,n.kt)("inlineCode",{parentName:"p"},"$()")," is the repetition part - this code will be inserted once for each time the repetition matches on the matcher side."),(0,n.kt)("p",null,"So if we were to write ",(0,n.kt)("inlineCode",{parentName:"p"},"vec![1, 2, 3]"),", at compile time this would get replaced with:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-rust"},"{\n    let mut temp_vec = Vec::new();\n    temp_vec.push(1);\n    temp_vec.push(2);\n    temp_vec.push(3);\n    temp_vec\n}\n")),(0,n.kt)("h2",{id:"procedural-macros-for-generating-code-from-attributes"},"Procedural Macros for Generating Code from Attributes"),(0,n.kt)("p",null,"A ",(0,n.kt)("em",{parentName:"p"},"procedural macro")," is a Rust function that generates code. There are three kinds of procedural macros: custom derive, attribute-like, and function-like. When we ",(0,n.kt)("inlineCode",{parentName:"p"},"#[derive()]")," a trait, it's going through a custom-derive macro."),(0,n.kt)("p",null,"TODO: Finish this section. For now, dear reader, I direct you ",(0,n.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/stable/book/ch19-06-macros.html#procedural-macros-for-generating-code-from-attributes"},"the original version of this section"),"."))}u.isMDXComponent=!0}}]);