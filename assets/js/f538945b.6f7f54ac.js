"use strict";(self.webpackChunkrust_book_abridged=self.webpackChunkrust_book_abridged||[]).push([[800],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>u});var i=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},r=Object.keys(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=i.createContext({}),h=function(e){var t=i.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=h(e.components);return i.createElement(l.Provider,{value:t},e.children)},m="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},f=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),m=h(n),f=a,u=m["".concat(l,".").concat(f)]||m[f]||c[f]||r;return n?i.createElement(u,o(o({ref:t},p),{},{components:n})):i.createElement(u,o({ref:t},p))}));function u(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,o=new Array(r);o[0]=f;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[m]="string"==typeof e?e:a,o[1]=s;for(var h=2;h<r;h++)o[h]=n[h];return i.createElement.apply(null,o)}return i.createElement.apply(null,n)}f.displayName="MDXCreateElement"},1834:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>c,frontMatter:()=>r,metadata:()=>s,toc:()=>h});var i=n(7462),a=(n(7294),n(3905));const r={},o="10.3 - Validating References with Lifetimes",s={unversionedId:"ch10/ch10-03-lifetimes",id:"ch10/ch10-03-lifetimes",title:"10.3 - Validating References with Lifetimes",description:"TODO: This section needs some rework.  If you want to get deep into how lifetimes work from the compiler's perspective, this is a good read.",source:"@site/docs/ch10/ch10-03-lifetimes.md",sourceDirName:"ch10",slug:"/ch10/ch10-03-lifetimes",permalink:"/rust-book-abridged/ch10/ch10-03-lifetimes",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/ch10/ch10-03-lifetimes.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"10.2 - Traits: Defining Shared Behavior",permalink:"/rust-book-abridged/ch10/ch10-02-traits"},next:{title:"11 - Writing Automated Tests",permalink:"/rust-book-abridged/ch11-automated-tests"}},l={},h=[{value:"Preventing Dangling References with Lifetimes",id:"preventing-dangling-references-with-lifetimes",level:2},{value:"Generic Lifetimes in Functions",id:"generic-lifetimes-in-functions",level:2},{value:"Lifetime Annotation Syntax",id:"lifetime-annotation-syntax",level:2},{value:"Lifetime Annotations in Function Signatures",id:"lifetime-annotations-in-function-signatures",level:2},{value:"Thinking in Terms of Lifetimes",id:"thinking-in-terms-of-lifetimes",level:2},{value:"Lifetime Annotations in Struct Definitions",id:"lifetime-annotations-in-struct-definitions",level:2},{value:"Lifetime Elision",id:"lifetime-elision",level:2},{value:"Lifetime Annotations in Method Definitions",id:"lifetime-annotations-in-method-definitions",level:2},{value:"The Static Lifetime",id:"the-static-lifetime",level:2},{value:"Generic Type Parameters, Trait Bounds, and Lifetimes Together",id:"generic-type-parameters-trait-bounds-and-lifetimes-together",level:2},{value:"Further Reading",id:"further-reading",level:2}],p={toc:h},m="wrapper";function c(e){let{components:t,...n}=e;return(0,a.kt)(m,(0,i.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"103---validating-references-with-lifetimes"},"10.3 - Validating References with Lifetimes"),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"},"TODO: This section needs some rework.  If you want to get deep into how lifetimes work from the compiler's perspective, ",(0,a.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/nomicon/subtyping.html"},"this")," is a good read.")),(0,a.kt)("p",null,"Every value in Rust has a ",(0,a.kt)("em",{parentName:"p"},"lifetime")," - a point in the code where the value is created, and a point in the code where the value is destroyed. Every reference in Rust has two lifetimes - the lifetime of the reference itself (from where it's created until where it is last used) and a lifetime of the value it points to. The lifetime of the reference obviously needs to be shorter than the lifetime of the value, otherwise the reference will point to freed memory."),(0,a.kt)("p",null,"Just as rustc infers the type of many of our parameters, in most cases Rust can infer the lifetime of a reference (usually from when it is created until it's last use in a function). Just as we can explicitly annotate a variable's type, we can also explicitly annotate the lifetime of a reference in cases where the compiler can't infer what we want."),(0,a.kt)("h2",{id:"preventing-dangling-references-with-lifetimes"},"Preventing Dangling References with Lifetimes"),(0,a.kt)("p",null,"The main point of ownership is to prevent dangling references - to prevent us from accessing memory after it has been freed. Here's an example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"fn main() {\n    let r;                // ---------+-- 'a\n                          //          |\n    {                     //          |\n        let x = 5;        // -+-- 'b  |\n        r = &x;           //  |       |\n    }                     // -+       |\n                          //          |\n    println!(\"r: {}\", r); //          |\n}                         // ---------+\n")),(0,a.kt)("p",null,"This won't compile. The variable ",(0,a.kt)("inlineCode",{parentName:"p"},"r")," is in scope for the entire ",(0,a.kt)("inlineCode",{parentName:"p"},"main()")," function, but it's a reference to ",(0,a.kt)("inlineCode",{parentName:"p"},"x")," which will be dropped when we reach the end of the inner scope. After we reach the end of that inner scope, ",(0,a.kt)("inlineCode",{parentName:"p"},"r")," is now a reference to freed memory, so Rust's ",(0,a.kt)("em",{parentName:"p"},"borrow checker")," won't let us use it."),(0,a.kt)("p",null,"More formally, we can say that ",(0,a.kt)("inlineCode",{parentName:"p"},"r")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"x")," have different lifetimes, which we've marked in the comments of this example, using the labels ",(0,a.kt)("inlineCode",{parentName:"p"},"'a")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"'b")," (strange names, but this is actually a bit of foreshadowing). The borrow checker sees that ",(0,a.kt)("inlineCode",{parentName:"p"},"r")," has a lifetime of ",(0,a.kt)("inlineCode",{parentName:"p"},"'a"),", but references memory that has the lifetime ",(0,a.kt)("inlineCode",{parentName:"p"},"'b"),", and since ",(0,a.kt)("inlineCode",{parentName:"p"},"'b")," is shorter than ",(0,a.kt)("inlineCode",{parentName:"p"},"'a"),", the borrow checker won't allow this."),(0,a.kt)("p",null,"This version fixes the bug:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"fn main() {\n    let x = 5;            // ----------+-- 'b\n                          //           |\n    let r = &x;           // --+-- 'a  |\n                          //   |       |\n    println!(\"r: {}\", r); //   |       |\n                          // --+       |\n}                         // ----------+\n")),(0,a.kt)("p",null,"Here ",(0,a.kt)("inlineCode",{parentName:"p"},"x")," has a larger lifetime than ",(0,a.kt)("inlineCode",{parentName:"p"},"r"),", so ",(0,a.kt)("inlineCode",{parentName:"p"},"r")," can be a valid reference to ",(0,a.kt)("inlineCode",{parentName:"p"},"x"),"."),(0,a.kt)("h2",{id:"generic-lifetimes-in-functions"},"Generic Lifetimes in Functions"),(0,a.kt)("p",null,"Now for an example that doesn't compile, for what might not at first be obvious reasons. We're going to pass two string slices to a ",(0,a.kt)("inlineCode",{parentName:"p"},"longest()")," function, and it will return back whichever is longer:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n    let string1 = String::from("abcd");\n    let string2 = "xyz";\n\n    let result = longest(string1.as_str(), string2);\n    println!("The longest string is {}", result);\n}\n\n// This doesn\'t work!\nfn longest(x: &str, y: &str) -> &str {\n    if x.len() > y.len() {\n        x\n    } else {\n        y\n    }\n}\n')),(0,a.kt)("p",null,"If we try to compile this, we get an error from the borrow checker. When the Rust compiler checks a call to a function, it doesn't look at the contents of the function, only at the signature. The root of the problem here is that in this function, the rust compiler doesn't know ahead of time whether we're going to return ",(0,a.kt)("inlineCode",{parentName:"p"},"x")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"y"),", and since these may have different lifetimes, the compiler can't know how long the returned reference will be valid for. Consider this example of calling this function:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n    let string1 = String::from("abcd");\n    let result;\n\n    {\n        let string2 = String::from("xyz");\n        result = longest(&string1, &string2);\n    }\n\n    // This shouldn\'t compile! But how does rust know that?\n    println!("The longest string is {}", result);\n}\n')),(0,a.kt)("p",null,"Here if ",(0,a.kt)("inlineCode",{parentName:"p"},"longest()")," returned the reference to ",(0,a.kt)("inlineCode",{parentName:"p"},"string1"),", it would still be valid by the time we get to the ",(0,a.kt)("inlineCode",{parentName:"p"},"println!"),", but if it returned the reference to ",(0,a.kt)("inlineCode",{parentName:"p"},"string2")," it would not. How is the borrow checker supposed to decide if the call to ",(0,a.kt)("inlineCode",{parentName:"p"},"longest()")," is valid? The answer is that it can't. At least, not without a little help from us."),(0,a.kt)("h2",{id:"lifetime-annotation-syntax"},"Lifetime Annotation Syntax"),(0,a.kt)("p",null,"We fix this problem by telling the compiler about the relationship between these references. We do this with ",(0,a.kt)("em",{parentName:"p"},"lifetime annotations"),". Lifetime references are of the form ",(0,a.kt)("inlineCode",{parentName:"p"},"'a"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"&i32        // a reference\n&'a i32     // a reference with an explicit lifetime\n&'a mut i32 // a mutable reference with an explicit lifetime\n")),(0,a.kt)("p",null,"A lifetime annotation on a single variable isn't very meaningful. Lifetime annotations really describe a constraint on the relationship of references between multiple variables."),(0,a.kt)("h2",{id:"lifetime-annotations-in-function-signatures"},"Lifetime Annotations in Function Signatures"),(0,a.kt)("p",null,"We can declare a lifetime annotation for a function in much the same way we add generic types. The lifetime annotation must start with a ",(0,a.kt)("inlineCode",{parentName:"p"},"'"),". Typically they are single characters, much like generic types. And just like generic types, these will be filled in with a real lifetime for each call to the function."),(0,a.kt)("p",null,"We can fix the ",(0,a.kt)("inlineCode",{parentName:"p"},"longest()")," function in our previous example with:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {\n    if x.len() > y.len() {\n        x\n    } else {\n        y\n    }\n}\n")),(0,a.kt)("p",null,"Think about this a bit like a generic function (the syntax is similar for a good reason). We're saying here there exists some lifetime which we're going to call ",(0,a.kt)("inlineCode",{parentName:"p"},"'a"),", and the variables ",(0,a.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"y")," both life at least as long as this hypothetical ",(0,a.kt)("inlineCode",{parentName:"p"},"'a"),". They don't have to both be the same lifetime, they just both have to be valid at the start and end of ",(0,a.kt)("inlineCode",{parentName:"p"},"'a"),". Then in the case of this function we're making the claim that the value we return is going to be valid for this same lifetime. At compile time, the compiler will see how long the passed in ",(0,a.kt)("inlineCode",{parentName:"p"},"x")," lives, how long the passed in ",(0,a.kt)("inlineCode",{parentName:"p"},"y")," lives, and then it will verify that the result of this function isn't used anywhere outside of that lifetime."),(0,a.kt)("p",null,"Putting this a bit more succinctly, we're telling the compiler that the return value of ",(0,a.kt)("inlineCode",{parentName:"p"},"longest()")," will live at least as long as the shorter lifetime of ",(0,a.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"y"),". When the rust compiler analyzes a call to ",(0,a.kt)("inlineCode",{parentName:"p"},"longest()")," it can now mark it as an error if the two parameters passed in don't adhere to this constraint."),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"},"Lifetime annotations don't actually change the lifetime of the references passed in, it only gives the borrow checker enough information to work out whether a call is valid.")),(0,a.kt)("p",null,"Returning to this example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n    let string1 = String::from("abcd");\n    let result;\n\n    {\n        let string2 = String::from("xyz");\n        result = longest(&string1, &string2);\n    }\n\n    // This doesn\'t compile!\n    println!("The longest string is {}", result);\n}\n')),(0,a.kt)("p",null,"Here the compiler now knows that the return value of ",(0,a.kt)("inlineCode",{parentName:"p"},"longest()")," is only as long as the shorter of ",(0,a.kt)("inlineCode",{parentName:"p"},"&string1")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"&string2"),", so it knows that the use of ",(0,a.kt)("inlineCode",{parentName:"p"},"result")," in the ",(0,a.kt)("inlineCode",{parentName:"p"},"println!")," macro is invalid."),(0,a.kt)("h2",{id:"thinking-in-terms-of-lifetimes"},"Thinking in Terms of Lifetimes"),(0,a.kt)("p",null,"The way we annotate lifetimes depends on what the function is doing. If we changed ",(0,a.kt)("inlineCode",{parentName:"p"},"longest()")," to only ever return the first parameter, we could annotate the lifetimes as:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"fn longest<'a>(x: &'a str, y: &str) -> &'a str {\n    x\n}\n")),(0,a.kt)("p",null,"This tells rustc that the lifetime of the return value is the same as the lifetime of the first parameter."),(0,a.kt)("p",null,"The lifetime of the return value must have the same annotation as at least one of the parameters (or be ",(0,a.kt)("inlineCode",{parentName:"p"},"'static"),", which we'll discuss in a moment). If you created a reference to something you create inside the function and return it, whatever you created will be dropped at the end of the function, so the reference will be invalid."),(0,a.kt)("h2",{id:"lifetime-annotations-in-struct-definitions"},"Lifetime Annotations in Struct Definitions"),(0,a.kt)("p",null,"So far all the structs we've created in this book have owned all their types. If we want to store a reference in a struct, we can, but we need to explicitly annotate it's lifetime. Just like a function, we do this with the generic syntax:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"struct ImportantExcerpt<'a> {\n    part: &'a str,\n}\n\nfn main() {\n    let novel = String::from(\"Call me Ishmael. Some years ago...\");\n    let first_sentence = novel.split('.').next().expect(\"Could not find a '.'\");\n\n    let i = ImportantExcerpt {\n        part: first_sentence,\n    };\n}\n")),(0,a.kt)("p",null,"Again, it's helpful to think about this like we would any other generic declaration. When we write ",(0,a.kt)("inlineCode",{parentName:"p"},"ImportantExcerpt<'a>")," we are saying \"there exists some lifetime which we'll call ",(0,a.kt)("inlineCode",{parentName:"p"},"'a"),"\" - we don't know what that lifetime is yet, and we won't know until someone creates an actual instance of this struct. When we write ",(0,a.kt)("inlineCode",{parentName:"p"},"part: &'a str"),', we are saying "when someone reads this ref, it has the lifetime ',(0,a.kt)("inlineCode",{parentName:"p"},"'a"),'" (and if someone later writes a new value to this ref, it must have a lifetime of at least ',(0,a.kt)("inlineCode",{parentName:"p"},"'a"),"). At compile time, the compiler will fill in the generic lifetimes with real lifetimes from your program, and then verify that the constraints hold."),(0,a.kt)("p",null,"Here this struct has only a single reference, and so it might seem odd that we have to give an explicit lifetime for it. You might think the compiler could automatically figure out the lifetime here (and perhaps one day in this trivial example it will - Rust is evolving pretty rapidly)."),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"},"The original ",(0,a.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/stable/book/ch10-03-lifetime-syntax.html#lifetime-annotations-in-struct-definitions"},'"The Rust Programming Language"'),' here said that "this annotation means an instance of ',(0,a.kt)("inlineCode",{parentName:"p"},"ImportantExcerpt")," can't outlive the reference it holds in its part field,\" but I found that not a helpful way to think about this - of course a struct can't outlive any references stored inside it. I found ",(0,a.kt)("a",{parentName:"p",href:"https://stackoverflow.com/questions/27785671/why-can-the-lifetimes-not-be-elided-in-a-struct-definition/27785916#27785916"},"this answer on Stack Overflow")," to be a lot more illuminating.")),(0,a.kt)("p",null,"Here's an example where a struct requires two different lifetime annotations (borrowed from ",(0,a.kt)("a",{parentName:"p",href:"https://stackoverflow.com/questions/29861388/when-is-it-useful-to-define-multiple-lifetimes-in-a-struct/66791361#66791361"},"this Stack Overflow discussion")," which has some other good examples too):"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"struct Point<'a, 'b> {\n    x: &'a i32,\n    y: &'b i32,\n}\n\nfn main() {\n    let x = 1;\n    let v;\n    {\n        let y = 2;\n        let f = Point { x: &x, y: &y };\n        v = f.x;\n    }\n    println!(\"{}\", *v);\n}\n")),(0,a.kt)("p",null,"The interesting thing here is that we're copying a reference out of a struct and then using it after the struct has been dropped. This is okay because in this case the lifetime of the reference is longer than that of the struct. There's no way the compiler could know this without lifetime annotations. We we create the ",(0,a.kt)("inlineCode",{parentName:"p"},"Point<'a, 'b>")," here, the compiler fills in ",(0,a.kt)("inlineCode",{parentName:"p"},"'a")," with the lifetime of ",(0,a.kt)("inlineCode",{parentName:"p"},"x = 1"),", so when we do ",(0,a.kt)("inlineCode",{parentName:"p"},"v = f.x")," the compiler knows v also has that same lifetime. Also in this example, if you tried to give both ",(0,a.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"y")," the same lifetime annotation, this would fail to compile."),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"Similar to trait bounds, we can add a ",(0,a.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/reference/trait-bounds.html#lifetime-bounds"},(0,a.kt)("em",{parentName:"a"},"lifetime bound"))," to a lifetime annotation in a function or a struct."),(0,a.kt)("pre",{parentName:"admonition"},(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"struct Point<'a, 'b: 'a> {\n    x: &'a f32,\n    y: &'b f32,\n}\n")),(0,a.kt)("p",{parentName:"admonition"},"You can read ",(0,a.kt)("inlineCode",{parentName:"p"},"'b: 'a"),' as "',(0,a.kt)("inlineCode",{parentName:"p"},"'b")," outlives ",(0,a.kt)("inlineCode",{parentName:"p"},"'a"),'", and this implies that ',(0,a.kt)("inlineCode",{parentName:"p"},"'b")," must be at least as long as ",(0,a.kt)("inlineCode",{parentName:"p"},"'a"),". There are very few cases where you would need to do such a thing, though.")),(0,a.kt)("h2",{id:"lifetime-elision"},"Lifetime Elision"),(0,a.kt)("p",null,"Way back in ",(0,a.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch04-ownership",title:"Chapter 4: Ownership, References, and Slices"},"chapter 4"),", we wrote this function:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"fn first_word(s: &str) -> &str {\n    let bytes = s.as_bytes();\n\n    for (i, &item) in bytes.iter().enumerate() {\n        if item == b' ' {\n            return &s[0..i];\n        }\n    }\n\n    &s[..]\n}\n")),(0,a.kt)("p",null,"How come this compiles without lifetime annotations? Why don't we have to tell the compiler that the return value has the same lifetime as ",(0,a.kt)("inlineCode",{parentName:"p"},"s"),"? Actually, in the pre-1.0 days of Rust, lifetime annotations would have been mandatory here. But there are certain cases where Rust can now work out the lifetime on it's own. We call this ",(0,a.kt)("em",{parentName:"p"},"lifetime elision"),", and say that the compiler ",(0,a.kt)("em",{parentName:"p"},"elides")," these lifetime annotations for us."),(0,a.kt)("p",null,"What the compiler does is to assign a different lifetime to every reference in the parameter list (",(0,a.kt)("inlineCode",{parentName:"p"},"'a")," for the first one, ",(0,a.kt)("inlineCode",{parentName:"p"},"'b")," for the second, and so on...). If there is exactly one input lifetime parameter, that lifetime is automatically assigned to all output parameters. If there is more than one input lifetime parameter but one of them is for ",(0,a.kt)("inlineCode",{parentName:"p"},"&self"),", then the lifetime of ",(0,a.kt)("inlineCode",{parentName:"p"},"self")," is assigned to all output parameters. Otherwise, the compiler will error."),(0,a.kt)("p",null,"In the case above, there's only one lifetime that ",(0,a.kt)("inlineCode",{parentName:"p"},"first_word")," could really be returning; if ",(0,a.kt)("inlineCode",{parentName:"p"},"first_word")," created a new ",(0,a.kt)("inlineCode",{parentName:"p"},"String")," and tried to return a reference to it, the new ",(0,a.kt)("inlineCode",{parentName:"p"},"String")," would be dropped when we leave the function and the reference would be invalid. The only sensible reference for it to return comes from ",(0,a.kt)("inlineCode",{parentName:"p"},"s"),", so Rust infers this for us. (It ",(0,a.kt)("em",{parentName:"p"},"could")," be a static lifetime, but if it were we'd have to explicitly annotate it as such.)"),(0,a.kt)("h2",{id:"lifetime-annotations-in-method-definitions"},"Lifetime Annotations in Method Definitions"),(0,a.kt)("p",null,"We can add lifetime annotations to methods using the exact same generic syntax we use for generic structs:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"impl<'a> ImportantExcerpt<'a> {\n    fn level(&self) -> i32 {\n        3\n    }\n\n    fn announce_and_return_part(&self, announcement: &str) -> &str {\n        println!(\"Attention please: {}\", announcement);\n        self.part\n    }\n}\n")),(0,a.kt)("p",null,"Here ",(0,a.kt)("inlineCode",{parentName:"p"},"'a")," refers to the lifetime of the struct itself, but thanks to lifetime elision, in ",(0,a.kt)("inlineCode",{parentName:"p"},"announce_and_return_part()"),", the return value is automatically given the same lifetime as ",(0,a.kt)("inlineCode",{parentName:"p"},"self,")," so we don't actually have to use it."),(0,a.kt)("h2",{id:"the-static-lifetime"},"The Static Lifetime"),(0,a.kt)("p",null,"There's a special lifetime called the ",(0,a.kt)("inlineCode",{parentName:"p"},"'static")," lifetime:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'let s: &\'static str = "I have a static lifetime.";\n')),(0,a.kt)("p",null,"This is a slice of a string that's part of the program's binary, so it will always be available. you may see the ",(0,a.kt)("inlineCode",{parentName:"p"},"'static")," lifetime mentioned in error messages when Rust suggests a fix, but unless you actually want a reference that lasts the life of your program, likely the real problem is that you're trying to create a dangling reference or there's lifetime mismatch."),(0,a.kt)("h2",{id:"generic-type-parameters-trait-bounds-and-lifetimes-together"},"Generic Type Parameters, Trait Bounds, and Lifetimes Together"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"use std::fmt::Display;\n\nfn longest_with_an_announcement<'a, T>(\n    x: &'a str,\n    y: &'a str,\n    announcement: T,\n) -> &'a str\nwhere\n    T: Display,\n{\n    println!(\"Announcement! {}\", announcement);\n    if x.len() > y.len() {\n        x\n    } else {\n        y\n    }\n}\n")),(0,a.kt)("p",null,"This takes two string slices and returns whichever is longer. It also prints an announcement, which is passed in as a parameter and can be any type that implements the ",(0,a.kt)("inlineCode",{parentName:"p"},"Display")," trait. (If someone showed you this code before you started reading this book, I wonder what would you have thought it meant?)"),(0,a.kt)("h2",{id:"further-reading"},"Further Reading"),(0,a.kt)("p",null,"There are some advanced cases where lifetime annotations are required that we haven't discussed here (for example trait bounds sometimes require ",(0,a.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/stable/reference/types/trait-object.html#trait-object-lifetime-bounds"},"lifetime annotations"),", but they are usually inferred). ",(0,a.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/reference/index.html"},"The Rust Reference")," is a good place to read about this sort of thing when you're a little more comfortable with the language."),(0,a.kt)("p",null,"Lifetimes and ownership are such a central and important part of Rust that I'll also direct you to ",(0,a.kt)("a",{parentName:"p",href:"https://mobiarch.wordpress.com/2015/06/29/understanding-lifetime-in-rust-part-i/"},"this excellent two part blog post")," on the subject."),(0,a.kt)("p",null,"Continue to ",(0,a.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch11-automated-tests",title:"Chapter 11: Writing Automated Tests"},"chapter 11"),"."))}c.isMDXComponent=!0}}]);