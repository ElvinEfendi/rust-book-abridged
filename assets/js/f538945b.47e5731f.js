"use strict";(self.webpackChunkrust_book_abridged=self.webpackChunkrust_book_abridged||[]).push([[7800],{3905:(e,t,n)=>{n.d(t,{Zo:()=>h,kt:()=>u});var i=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},r=Object.keys(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=i.createContext({}),p=function(e){var t=i.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},h=function(e){var t=p(e.components);return i.createElement(s.Provider,{value:t},e.children)},c="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},f=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,s=e.parentName,h=l(e,["components","mdxType","originalType","parentName"]),c=p(n),f=a,u=c["".concat(s,".").concat(f)]||c[f]||m[f]||r;return n?i.createElement(u,o(o({ref:t},h),{},{components:n})):i.createElement(u,o({ref:t},h))}));function u(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,o=new Array(r);o[0]=f;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[c]="string"==typeof e?e:a,o[1]=l;for(var p=2;p<r;p++)o[p]=n[p];return i.createElement.apply(null,o)}return i.createElement.apply(null,n)}f.displayName="MDXCreateElement"},1834:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>m,frontMatter:()=>r,metadata:()=>l,toc:()=>p});var i=n(7462),a=(n(7294),n(3905));const r={},o="10.3 - Validating References with Lifetimes",l={unversionedId:"ch10/ch10-03-lifetimes",id:"ch10/ch10-03-lifetimes",title:"10.3 - Validating References with Lifetimes",description:"Every reference in Rust has a lifetime where the reference is valid. This has to do with ownership, so it's a feature that's somewhat unique to Rust.",source:"@site/docs/ch10/ch10-03-lifetimes.md",sourceDirName:"ch10",slug:"/ch10/ch10-03-lifetimes",permalink:"/ch10/ch10-03-lifetimes",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/ch10/ch10-03-lifetimes.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"10.2 - Traits: Defining Shared Behavior",permalink:"/ch10/ch10-02-traits"},next:{title:"11 - Writing Automated Tests",permalink:"/ch11-automated-tests"}},s={},p=[{value:"Preventing Dangling References with Lifetimes",id:"preventing-dangling-references-with-lifetimes",level:2},{value:"Generic Lifetimes in Functions",id:"generic-lifetimes-in-functions",level:2},{value:"Lifetime Annotation Syntax",id:"lifetime-annotation-syntax",level:2},{value:"Lifetime Annotations in Function Signatures",id:"lifetime-annotations-in-function-signatures",level:2},{value:"Thinking in Terms of Lifetimes",id:"thinking-in-terms-of-lifetimes",level:2},{value:"Lifetime Annotations in Struct Definitions",id:"lifetime-annotations-in-struct-definitions",level:2},{value:"Lifetime Elision",id:"lifetime-elision",level:2},{value:"Lifetime Annotations in Method Definitions",id:"lifetime-annotations-in-method-definitions",level:2},{value:"The Static Lifetime",id:"the-static-lifetime",level:2},{value:"Generic Type Parameters, Trait Bounds, and Lifetimes Together",id:"generic-type-parameters-trait-bounds-and-lifetimes-together",level:2},{value:"Further Reading",id:"further-reading",level:2}],h={toc:p},c="wrapper";function m(e){let{components:t,...n}=e;return(0,a.kt)(c,(0,i.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"103---validating-references-with-lifetimes"},"10.3 - Validating References with Lifetimes"),(0,a.kt)("p",null,"Every reference in Rust has a ",(0,a.kt)("em",{parentName:"p"},"lifetime")," where the reference is valid. This has to do with ",(0,a.kt)("a",{parentName:"p",href:"/ch04-ownership",title:"Chapter 4: Ownership, References, and Slices"},"ownership"),", so it's a feature that's somewhat unique to Rust."),(0,a.kt)("p",null,"Just as rustc infers the type of many of our parameters, in most cases Rust can infer the lifetime of a reference (usually from when it is created until it's last use in a function). Just as we can explicitly annotate a variable's type, we can also explicitly annotate the lifetime of a reference in cases where the compiler can't infer what we want."),(0,a.kt)("h2",{id:"preventing-dangling-references-with-lifetimes"},"Preventing Dangling References with Lifetimes"),(0,a.kt)("p",null,"The main point of ownership is to prevent dangling references - to prevent us from accessing memory after it has been freed. Here's an example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"fn main() {\n    let r;                // ---------+-- 'a\n                          //          |\n    {                     //          |\n        let x = 5;        // -+-- 'b  |\n        r = &x;           //  |       |\n    }                     // -+       |\n                          //          |\n    println!(\"r: {}\", r); //          |\n}                         // ---------+\n")),(0,a.kt)("p",null,"If you try this, it won't compile. The variable ",(0,a.kt)("inlineCode",{parentName:"p"},"r")," is in scope for the entire ",(0,a.kt)("inlineCode",{parentName:"p"},"main()")," function, but it's a reference to ",(0,a.kt)("inlineCode",{parentName:"p"},"x")," which will be dropped when we reach the end of the inner scope. After we reach the end of that inner scope, ",(0,a.kt)("inlineCode",{parentName:"p"},"r")," is now a reference to freed memory, so Rust's ",(0,a.kt)("em",{parentName:"p"},"borrow checker")," won't let us use it."),(0,a.kt)("p",null,"More formally, we can say that ",(0,a.kt)("inlineCode",{parentName:"p"},"r")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"x")," have different lifetimes, which we've marked in the comments of this example. The borrow checker sees that ",(0,a.kt)("inlineCode",{parentName:"p"},"r")," has a lifetime of ",(0,a.kt)("inlineCode",{parentName:"p"},"'a"),", but references memory that has the lifetime ",(0,a.kt)("inlineCode",{parentName:"p"},"'b"),", and since ",(0,a.kt)("inlineCode",{parentName:"p"},"'b")," is shorter than ",(0,a.kt)("inlineCode",{parentName:"p"},"'a"),", the borrow checker won't allow this."),(0,a.kt)("p",null,"This version fixes the bug:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"fn main() {\n    let x = 5;            // ----------+-- 'b\n                          //           |\n    let r = &x;           // --+-- 'a  |\n                          //   |       |\n    println!(\"r: {}\", r); //   |       |\n                          // --+       |\n}                         // ----------+\n")),(0,a.kt)("p",null,"Here ",(0,a.kt)("inlineCode",{parentName:"p"},"x")," has a larger lifetime than ",(0,a.kt)("inlineCode",{parentName:"p"},"r"),", so ",(0,a.kt)("inlineCode",{parentName:"p"},"r")," can be a valid reference to ",(0,a.kt)("inlineCode",{parentName:"p"},"x"),"."),(0,a.kt)("h2",{id:"generic-lifetimes-in-functions"},"Generic Lifetimes in Functions"),(0,a.kt)("p",null,"Now for a confusing example that doesn't compile. We're going to pass two string slices to a ",(0,a.kt)("inlineCode",{parentName:"p"},"longest()")," function, and it will return back whichever is longer:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n    let string1 = String::from("abcd");\n    let string2 = "xyz";\n\n    let result = longest(string1.as_str(), string2);\n    println!("The longest string is {}", result);\n}\n\n// This doesn\'t work!\nfn longest(x: &str, y: &str) -> &str {\n    if x.len() > y.len() {\n        x\n    } else {\n        y\n    }\n}\n')),(0,a.kt)("p",null,"If we try to compile this, we get an error from the borrow checker. The root of the problem here is that in this function, the rust compiler doesn't know ahead of time whether we're going to return ",(0,a.kt)("inlineCode",{parentName:"p"},"x")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"y"),", and since these may have different lifetimes, the compiler can't know how long the returned reference will be valid for. Consider this example of calling this function:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n    let string1 = String::from("abcd");\n    let result;\n\n    {\n        let string2 = String::from("xyz");\n        result = longest(&string1, &string2);\n    }\n\n    // This shouldn\'t compile! But how does rust know that?\n    println!("The longest string is {}", result);\n}\n')),(0,a.kt)("p",null,"Here if ",(0,a.kt)("inlineCode",{parentName:"p"},"longest()")," returned the reference to ",(0,a.kt)("inlineCode",{parentName:"p"},"string1"),", it would still be valid by the time we get to the ",(0,a.kt)("inlineCode",{parentName:"p"},"println!"),", but if it returned the reference to ",(0,a.kt)("inlineCode",{parentName:"p"},"string2")," it would not. How is the borrow checker supposed to decide if the call to ",(0,a.kt)("inlineCode",{parentName:"p"},"longest()")," is valid? The answer is that it can't. At least, not without a little help from us."),(0,a.kt)("h2",{id:"lifetime-annotation-syntax"},"Lifetime Annotation Syntax"),(0,a.kt)("p",null,"We fix this problem by telling the compiler about the relationship between these references. We do this with ",(0,a.kt)("em",{parentName:"p"},"lifetime annotations"),". Lifetime references are of the form ",(0,a.kt)("inlineCode",{parentName:"p"},"'a"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"&i32        // a reference\n&'a i32     // a reference with an explicit lifetime\n&'a mut i32 // a mutable reference with an explicit lifetime\n")),(0,a.kt)("p",null,"A lifetime annotation on a single variable isn't very meaningful. Lifetime annotations really describe a constraint on the relationship of references between multiple variables."),(0,a.kt)("h2",{id:"lifetime-annotations-in-function-signatures"},"Lifetime Annotations in Function Signatures"),(0,a.kt)("p",null,"We can declare a lifetime annotation for a function in much the same way we add generic types. The lifetime annotation must start with a ",(0,a.kt)("inlineCode",{parentName:"p"},"'"),". Typically they are single characters, much like generic types."),(0,a.kt)("p",null,"We can fix the ",(0,a.kt)("inlineCode",{parentName:"p"},"longest()")," function in our previous example with:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {\n    if x.len() > y.len() {\n        x\n    } else {\n        y\n    }\n}\n")),(0,a.kt)("p",null,"What we've done here is to tell the compiler that this function takes an ",(0,a.kt)("inlineCode",{parentName:"p"},"x")," and a ",(0,a.kt)("inlineCode",{parentName:"p"},"y"),", both of which will live for some lifetime which we've called ",(0,a.kt)("inlineCode",{parentName:"p"},"'a"),". This doesn't mean the two parameters passed in need to have the exact same lifetime, it only means that ",(0,a.kt)("inlineCode",{parentName:"p"},"'a")," is the lifetime of the shorter of the two. We say we're going to return a reference that has the same lifetime. In other words we're telling the compiler that the return value of ",(0,a.kt)("inlineCode",{parentName:"p"},"longest()")," will live at least as long as the shorter lifetime of ",(0,a.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"y"),". When the rust compiler analyzes a call to ",(0,a.kt)("inlineCode",{parentName:"p"},"longest()")," it can now mark it as an error if the two parameters passed in don't adhere to this constraint."),(0,a.kt)("p",null,"It's important to note that these annotations don't actually change the lifetime of the references passed in, it only gives the borrow checker enough information to work out whether a call is valid."),(0,a.kt)("p",null,"Returning to this example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n    let string1 = String::from("abcd");\n    let result;\n\n    {\n        let string2 = String::from("xyz");\n        result = longest(&string1, &string2);\n    }\n\n    // This doesn\'t compile!\n    println!("The longest string is {}", result);\n}\n')),(0,a.kt)("p",null,"Here the compiler now knows that the return value of ",(0,a.kt)("inlineCode",{parentName:"p"},"longest()")," is only as long as the shorter of ",(0,a.kt)("inlineCode",{parentName:"p"},"&string1")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"&string2"),", so it knows that the use of ",(0,a.kt)("inlineCode",{parentName:"p"},"result")," in the ",(0,a.kt)("inlineCode",{parentName:"p"},"println!")," macro is invalid."),(0,a.kt)("h2",{id:"thinking-in-terms-of-lifetimes"},"Thinking in Terms of Lifetimes"),(0,a.kt)("p",null,"The way we annotate lifetimes depends on what the function is doing. If we changed ",(0,a.kt)("inlineCode",{parentName:"p"},"longest()")," to only ever return the first parameter, we could annotate the lifetimes as:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"fn longest<'a>(x: &'a str, y: &str) -> &'a str {\n    x\n}\n")),(0,a.kt)("p",null,"This tells rustc that the lifetime of the return value is the same as the lifetime of the first parameter."),(0,a.kt)("p",null,"The lifetime of the return value must have the same annotation as at least one of the parameters. If you created a reference to something you create inside the function and return it, whatever you created will be dropped at the end of the function, so the reference will be invalid."),(0,a.kt)("h2",{id:"lifetime-annotations-in-struct-definitions"},"Lifetime Annotations in Struct Definitions"),(0,a.kt)("p",null,"So far all the structs we've created in this book have owned all their types. If we want to store a reference in a struct, we can, but we need to annotate it's type. Just like a function, we do this with the generic syntax:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"struct ImportantExcerpt<'a> {\n    part: &'a str,\n}\n\nfn main() {\n    let novel = String::from(\"Call me Ishmael. Some years ago...\");\n    let first_sentence = novel.split('.').next().expect(\"Could not find a '.'\");\n    let i = ImportantExcerpt {\n        part: first_sentence,\n    };\n}\n")),(0,a.kt)("p",null,"Here what we're telling the compiler is that any ",(0,a.kt)("inlineCode",{parentName:"p"},"ImportantExcerpt")," struct can't outlive the reference in the ",(0,a.kt)("inlineCode",{parentName:"p"},"part")," field. (TODO: Why do we have to explicitly annotate this? I would think that no struct could outlive any reference contained within it. When would we ever use multiple different lifetimes in the same struct?)"),(0,a.kt)("h2",{id:"lifetime-elision"},"Lifetime Elision"),(0,a.kt)("p",null,"Way back in ",(0,a.kt)("a",{parentName:"p",href:"/ch04-ownership",title:"Chapter 4: Ownership, References, and Slices"},"chapter 4"),", we wrote this function:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"fn first_word(s: &str) -> &str {\n    let bytes = s.as_bytes();\n\n    for (i, &item) in bytes.iter().enumerate() {\n        if item == b' ' {\n            return &s[0..i];\n        }\n    }\n\n    &s[..]\n}\n")),(0,a.kt)("p",null,"How come this compiles without lifetime annotations? Actually, in the pre-1.0 days of Rust, it wouldn't have, as lifetime annotations would have been mandatory here. But, over time the Rust team found there were certain cases where the compiler could predictably determine the lifecycle on it's own, and in these cases they are now optional."),(0,a.kt)("p",null,"What the compiler does is to assign a different lifecycle to every reference in the parameter list (",(0,a.kt)("inlineCode",{parentName:"p"},"'a")," for the first one, ",(0,a.kt)("inlineCode",{parentName:"p"},"'b")," for the second, and so on...). If there is exactly one input lifetime parameter, that lifecycle is automatically assigned to all output parameters. If there is more than one input lifetime parameter but one of them is for ",(0,a.kt)("inlineCode",{parentName:"p"},"&self"),", then the lifetime of ",(0,a.kt)("inlineCode",{parentName:"p"},"self")," is assigned to all output parameters. Otherwise, the compiler will error."),(0,a.kt)("h2",{id:"lifetime-annotations-in-method-definitions"},"Lifetime Annotations in Method Definitions"),(0,a.kt)("p",null,"We can add lifetime annotations to methods using the exact same generic syntax we use for generic structs:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"impl<'a> ImportantExcerpt<'a> {\n    fn level(&self) -> i32 {\n        3\n    }\n\n    fn announce_and_return_part(&self, announcement: &str) -> &str {\n        println!(\"Attention please: {}\", announcement);\n        self.part\n    }\n}\n")),(0,a.kt)("p",null,"Here ",(0,a.kt)("inlineCode",{parentName:"p"},"'a")," refers to the lifetime of the struct itself, but thanks to lifetime elision, in ",(0,a.kt)("inlineCode",{parentName:"p"},"announce_and_return_part()"),", the return value is automatically given the same lifetime as ",(0,a.kt)("inlineCode",{parentName:"p"},"self,")," so we don't actually have to use it."),(0,a.kt)("h2",{id:"the-static-lifetime"},"The Static Lifetime"),(0,a.kt)("p",null,"There's a special lifetime called the ",(0,a.kt)("inlineCode",{parentName:"p"},"'static")," lifetime:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'let s: &\'static str = "I have a static lifetime.";\n')),(0,a.kt)("p",null,"This is a slice of a string that's part of the program's binary, so it will always be available. you may see the ",(0,a.kt)("inlineCode",{parentName:"p"},"'static")," lifetime mentioned in error messages when Rust suggests a fix, but unless you actually want a reference that lasts the life of your program, likely the real problem is that you're trying to create a dangling reference or there's lifetime mismatch."),(0,a.kt)("h2",{id:"generic-type-parameters-trait-bounds-and-lifetimes-together"},"Generic Type Parameters, Trait Bounds, and Lifetimes Together"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"use std::fmt::Display;\n\nfn longest_with_an_announcement<'a, T>(\n    x: &'a str,\n    y: &'a str,\n    ann: T,\n) -> &'a str\nwhere\n    T: Display,\n{\n    println!(\"Announcement! {}\", ann);\n    if x.len() > y.len() {\n        x\n    } else {\n        y\n    }\n}\n")),(0,a.kt)("p",null,"This takes two string slices and returns whichever is longer. It also prints an announcement, which is passed in as a parameter and can be any type that implements the ",(0,a.kt)("inlineCode",{parentName:"p"},"Display")," trait. I think this is a pretty good example of why, if you don't read this book or the original, you're going to struggle with Rust, because especially with the lifetime annotations this doesn't really look like any other programming language."),(0,a.kt)("h2",{id:"further-reading"},"Further Reading"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"/ch17-object-oriented-features",title:"Chapter 17: Object Oriented Features of Rust"},"Chapter 17")," discusses ",(0,a.kt)("em",{parentName:"p"},"trait objects"),", which we didn't talk about here. Something else we didn't talk about here are some more complex scenarios involving ",(0,a.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/stable/reference/trait-bounds.html"},"lifecycle annotations"),", but those are only needed in very advanced cases and are beyond the scope of this book."),(0,a.kt)("p",null,"Continue to ",(0,a.kt)("a",{parentName:"p",href:"/ch11-automated-tests",title:"Chapter 11: Writing Automated Tests"},"chapter 11"),"."))}m.isMDXComponent=!0}}]);