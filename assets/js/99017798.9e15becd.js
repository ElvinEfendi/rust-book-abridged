"use strict";(self.webpackChunkrust_book_abridged=self.webpackChunkrust_book_abridged||[]).push([[5293],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),u=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=u(e.components);return a.createElement(l.Provider,{value:t},e.children)},d="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=u(n),c=o,h=d["".concat(l,".").concat(c)]||d[c]||m[c]||r;return n?a.createElement(h,i(i({ref:t},p),{},{components:n})):a.createElement(h,i({ref:t},p))}));function h(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=c;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[d]="string"==typeof e?e:o,i[1]=s;for(var u=2;u<r;u++)i[u]=n[u];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},4108:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>m,frontMatter:()=>r,metadata:()=>s,toc:()=>u});var a=n(7462),o=(n(7294),n(3905));const r={},i="7 - Managing Growing Projects with Packages, Crates, and Modules",s={unversionedId:"ch07-packages-crates-modules",id:"ch07-packages-crates-modules",title:"7 - Managing Growing Projects with Packages, Crates, and Modules",description:"So far all of our examples have lived in a single file, but almost any non-trivial program would be too large to fit in a single file. Rust provides a number of tools to help us organize a project:",source:"@site/docs/ch07-packages-crates-modules.md",sourceDirName:".",slug:"/ch07-packages-crates-modules",permalink:"/ch07-packages-crates-modules",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/ch07-packages-crates-modules.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"6 - Enums and Pattern Matching",permalink:"/ch06-enums-and-pattern-matching"},next:{title:"8 - Common Collections",permalink:"/ch08-common-collections"}},l={},u=[{value:"7.1 Packages and Crates",id:"71-packages-and-crates",level:2},{value:"7.2 Defining Modules to Control Scope and Privacy",id:"72-defining-modules-to-control-scope-and-privacy",level:2},{value:"Grouping Related Code in Modules",id:"grouping-related-code-in-modules",level:3},{value:"7.3 Paths for Referring to an Item in the Module Tree",id:"73-paths-for-referring-to-an-item-in-the-module-tree",level:2},{value:"Starting Relative Paths with super",id:"starting-relative-paths-with-super",level:3},{value:"Making Structs and Enums Public",id:"making-structs-and-enums-public",level:3},{value:"7.4 - Bringing Paths into Scope with the <code>use</code> Keyword",id:"74---bringing-paths-into-scope-with-the-use-keyword",level:2},{value:"Creating Idiomatic use Paths",id:"creating-idiomatic-use-paths",level:3},{value:"Re-exporting Names with <code>pub use</code>",id:"re-exporting-names-with-pub-use",level:3},{value:"Using External Packages",id:"using-external-packages",level:3},{value:"Using Nested Paths to Clean Up Large use Lists",id:"using-nested-paths-to-clean-up-large-use-lists",level:3},{value:"The Glob Operator",id:"the-glob-operator",level:3},{value:"Separating Modules into Different Files",id:"separating-modules-into-different-files",level:2}],p={toc:u},d="wrapper";function m(e){let{components:t,...n}=e;return(0,o.kt)(d,(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"7---managing-growing-projects-with-packages-crates-and-modules"},"7 - Managing Growing Projects with Packages, Crates, and Modules"),(0,o.kt)("p",null,"So far all of our examples have lived in a single file, but almost any non-trivial program would be too large to fit in a single file. Rust provides a number of tools to help us organize a project:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("em",{parentName:"li"},"Modules")," group together related code, and let you control what is a private implementation detail and what should be public interface."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("em",{parentName:"li"},"Crates")," are a tree of modules that produce a library or an executable. Back in ",(0,o.kt)("a",{parentName:"li",href:"/ch02-guessing-game",title:"Chapter 2: Guessing Game"},"chapter 2")," we installed the ",(0,o.kt)("inlineCode",{parentName:"li"},"rand")," crate to help us generate random numbers."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("em",{parentName:"li"},"Paths")," are used to reference a function, struct, enum, etc... from some other module or crate."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("em",{parentName:"li"},"Packages")," are what you actually check into git (or your source control of choice) - a package contains a library crate, one or more binary crates, or both."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("em",{parentName:"li"},"Workspaces")," let you group together a large set of related packages, similar to a monorepo (TODO: Is this true?). We'll wait until ",(0,o.kt)("a",{parentName:"li",href:"/ch14-more-about-cargo",title:"Chapter 14: More About Cargo and Crates.io"},"chapter 14")," to talk about workspaces")),(0,o.kt)("h2",{id:"71-packages-and-crates"},"7.1 Packages and Crates"),(0,o.kt)("p",null,'In many compiled languages - C or Java for example - the "unit of compilation" is a single file. In a C project, every .c source file compiles to a single object file (a .o file on most platforms), and then all the .o files get linked together into a single executable (or into a dynamically linked library). If you change a .c file in a big project, you only have to recompile that single .c file and then relink all the object files.'),(0,o.kt)("p",null,"In Rust, the unit of compilation is the ",(0,o.kt)("em",{parentName:"p"},"crate"),'. Crates come in two forms - library crates and binary crates, but most of the crates you\'re going to deal with are libraries, so the terms "crate", "library", and "library crate" are all used interchangeably when talking about Rust.'),(0,o.kt)("p",null,"A ",(0,o.kt)("em",{parentName:"p"},"package")," is purely a cargo concept (in other words, ",(0,o.kt)("inlineCode",{parentName:"p"},"rustc")," doesn't know anything about packages). A package is what you get when you run ",(0,o.kt)("inlineCode",{parentName:"p"},"cargo new")," - a ",(0,o.kt)("em",{parentName:"p"},"cargo.toml")," file, and a src folder (possibly with subfolders) containing one or more source files."),(0,o.kt)("p",null,"The ",(0,o.kt)("em",{parentName:"p"},"crate root")," is the file (or files) that rustc starts working from. If a package contains a src/main.rs file with a ",(0,o.kt)("inlineCode",{parentName:"p"},"main")," function, then the package contains a binary crate with the same name as the package. If a package contains a ",(0,o.kt)("em",{parentName:"p"},"src/lib.rs"),", then it contains a library crate (again with the same name as the package). If it has both, then the package contains both a library crate and a binary crate. You might want to include both if you want a simple program that executes your library. For example, if you were writing a library to convert JPG images to PNG format, you might include both a library crate that other developers can use and a binary crate implementing a command line tool that uses the library. If you want to include more than one binary crate in a package, you can add files in src/bin. Each file placed there will be compiled as a separate binary crate."),(0,o.kt)("h2",{id:"72-defining-modules-to-control-scope-and-privacy"},"7.2 Defining Modules to Control Scope and Privacy"),(0,o.kt)("p",null,"A ",(0,o.kt)("em",{parentName:"p"},"module")," is quite similar to a package in Go, and is somewhat similar to a package in Java. If you're a JavaScript developer, then a module is close to an ESM module, except you can split a module up over multiple files."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"rustc")," always starts at the crate root (usually ",(0,o.kt)("em",{parentName:"p"},"src/main.rs")," or ",(0,o.kt)("em",{parentName:"p"},"src/lib.rs"),") - it compiles this file, and any time it finds a ",(0,o.kt)("inlineCode",{parentName:"p"},"mod")," statement, it adds the associated module to the crate and compiles it too. Suppose in ",(0,o.kt)("em",{parentName:"p"},"main.rs")," we have the statement ",(0,o.kt)("inlineCode",{parentName:"p"},"mod garden")," - Rust will look for the code for this module in three places:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Inline (e.g. ",(0,o.kt)("inlineCode",{parentName:"li"},"mod garden { /* code goes here */ }"),")"),(0,o.kt)("li",{parentName:"ul"},"In ",(0,o.kt)("em",{parentName:"li"},"src/garden.rs"),"."),(0,o.kt)("li",{parentName:"ul"},"In ",(0,o.kt)("em",{parentName:"li"},"src/garden/mod.rs")," (older style)")),(0,o.kt)("p",null,"Similarly modules can defined submodules. ",(0,o.kt)("em",{parentName:"p"},"src/garden.rs")," can have a ",(0,o.kt)("inlineCode",{parentName:"p"},"mod vegetables")," that might be defined in ",(0,o.kt)("em",{parentName:"p"},"src/garden/vegetables.rs"),' (note that garden\'s submodules go in a folder named "garden", not in the same folder).'),(0,o.kt)("p",null,"Note that we've marked the ",(0,o.kt)("em",{parentName:"p"},"src/garden/mod.rs"),' version as "older style". This is still supported (and as we\'ll see in ',(0,o.kt)("a",{parentName:"p",href:"/ch11-automated-tests",title:"Chapter 11: Writing Automated Tests"},"chapter 11")," it's very handy for writing integration tests) but the ",(0,o.kt)("em",{parentName:"p"},"src/garden.rs")," is the one you should use by default. If you try to use the mix the ",(0,o.kt)("inlineCode",{parentName:"p"},"[name].rs")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"[name]/mod.rs")," styles in the same module, you'll get a compiler error."),(0,o.kt)("p",null,"Every identifier at the top level of a Rust source file has a ",(0,o.kt)("em",{parentName:"p"},"path")," associated with it. If we created a struct called ",(0,o.kt)("inlineCode",{parentName:"p"},"Asparagus")," in the vegetables module, then the absolute path for that struct would be ",(0,o.kt)("inlineCode",{parentName:"p"},"crate::garden::vegetables::Asparagus"),"."),(0,o.kt)("p",null,"Each identifier declared in a source file is also private by default, meaning it can only be accessed by functions inside that module (or it's submodules - submodules always have visibility into the private details of their ancestors). To make any identifier public you use the ",(0,o.kt)("inlineCode",{parentName:"p"},"pub")," keyword, like ",(0,o.kt)("inlineCode",{parentName:"p"},"pub fn do_the_thing() {...}")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"pub mod garden"),"."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"use")," keyword is used to bring paths into scope. If you ",(0,o.kt)("inlineCode",{parentName:"p"},"use crate::garden:vegetables::Asparagus")," in a file, then you can use ",(0,o.kt)("inlineCode",{parentName:"p"},"Asparagus")," to refer to this struct instead of using the full path."),(0,o.kt)("h3",{id:"grouping-related-code-in-modules"},"Grouping Related Code in Modules"),(0,o.kt)("p",null,'In the restaurant industry, the dining room and other places of the restaurant where customers go is called the "front of house" and the kitchen and offices and parts where customers are rarely seen are called the "back of house". Let\'s create library for managing a restaurant. We\'ll run ',(0,o.kt)("inlineCode",{parentName:"p"},"cargo new restaurant --lib")," to create a library crate, and in ",(0,o.kt)("em",{parentName:"p"},"src/lib.rs")," we'll put:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"mod front_of_house {\n    mod hosting {\n        fn add_to_waitlist() {}\n\n        fn seat_at_table() {}\n    }\n\n    mod serving {\n        fn take_order() {}\n\n        fn serve_order() {}\n\n        fn take_payment() {}\n    }\n}\n")),(0,o.kt)("p",null,"We'll just defined the modules inline here, because this is convenient for the purposes of an example, but usually we'd split this modules up into multiple files."),(0,o.kt)("h2",{id:"73-paths-for-referring-to-an-item-in-the-module-tree"},"7.3 Paths for Referring to an Item in the Module Tree"),(0,o.kt)("p",null,"To refer to an item in the module tree, we use a path. Paths come in two forms:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"An ",(0,o.kt)("em",{parentName:"li"},"absolute path")," starts from the crate root. For external library creates we're using, this starts with the name of the crate (e.g. ",(0,o.kt)("inlineCode",{parentName:"li"},"rand"),") and for code within the current crate it starts with ",(0,o.kt)("inlineCode",{parentName:"li"},"crate"),"."),(0,o.kt)("li",{parentName:"ul"},"A ",(0,o.kt)("em",{parentName:"li"},"relative path")," starts from the current module. It starts with an identifier in the current module or with ",(0,o.kt)("inlineCode",{parentName:"li"},"self")," or ",(0,o.kt)("inlineCode",{parentName:"li"},"super"),".")),(0,o.kt)("p",null,"Using our restaurant example, let's say we want to call the ",(0,o.kt)("inlineCode",{parentName:"p"},"add_to_waitlist")," function. From the top level of src/lib.rs we could do this in two ways:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"mod front_of_house {\n    pub mod hosting {\n        pub fn add_to_waitlist() {}\n    }\n}\n\npub fn eat_at_restaurant() {\n    // Absolute path\n    crate::front_of_house::hosting::add_to_waitlist();\n\n    // Relative path, since this function is defined\n    // the same modules as `front_of_house`.\n    front_of_house::hosting::add_to_waitlist();\n}\n")),(0,o.kt)("p",null,"Relative paths have the clear advantage that they are shorter. Absolute paths have the advantage that, if you move a function from one place to another, all the absolute paths in that function won't have to change (although obviously all the paths pointing to the moved function will)."),(0,o.kt)("p",null,"We have to mark ",(0,o.kt)("inlineCode",{parentName:"p"},"hosting")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"add_to_waitlist")," as ",(0,o.kt)("inlineCode",{parentName:"p"},"pub")," in order for ",(0,o.kt)("inlineCode",{parentName:"p"},"eat_at_restaurant")," to compile. This is because ",(0,o.kt)("inlineCode",{parentName:"p"},"eat_at_restaurant")," is defined at the root of the crate, and ",(0,o.kt)("inlineCode",{parentName:"p"},"hosting")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"add_to_waitlist")," are in child modules. A parent cannot access the private contents of a another module, unless that other module is an ancestor - ",(0,o.kt)("inlineCode",{parentName:"p"},"add_to_waitlist")," could access private members of ",(0,o.kt)("inlineCode",{parentName:"p"},"front_of_house")," or the root of the crate."),(0,o.kt)("h3",{id:"starting-relative-paths-with-super"},"Starting Relative Paths with super"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"super")," keyword is used in a module path in exactly the same way as ",(0,o.kt)("inlineCode",{parentName:"p"},"..")," is used in a file path - it goes up one level in the module tree:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"fn deliver_order() {}\n\nmod back_of_house {\n    fn fix_incorrect_order() {\n        cook_order();\n        // Call into `deliver_order` in the parent module.\n        super::deliver_order();\n    }\n\n    fn cook_order() {}\n}\n")),(0,o.kt)("h3",{id:"making-structs-and-enums-public"},"Making Structs and Enums Public"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"pub")," is used to make an identifier visible outside of the module, but there are a few special considerations for structs and enums. When you make a ",(0,o.kt)("inlineCode",{parentName:"p"},"struct")," public, by default all of it's fields are private and can only be accessed inside the module. You need to mark individual fields as ",(0,o.kt)("inlineCode",{parentName:"p"},"pub")," if you want them to be used outside:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'mod back_of_house {\n    pub struct Breakfast {\n        pub toast: String,\n        seasonal_fruit: String,\n    }\n\n    impl Breakfast {\n        // Constructor for a summer Breakfast.\n        pub fn summer(toast: &str) -> Breakfast {\n            Breakfast {\n                toast: String::from(toast),\n                seasonal_fruit: String::from("peaches"),\n            }\n        }\n    }\n}\n\npub fn eat_at_restaurant() {\n    // Order a breakfast in the summer with Rye toast\n    let mut meal = back_of_house::Breakfast::summer("Rye");\n    // Change our mind about what bread we\'d like\n    meal.toast = String::from("Wheat");\n    println!("I\'d like {} toast please", meal.toast);\n\n    // The next line won\'t compile if we uncomment it; we\'re not allowed\n    // to see or modify the seasonal fruit that comes with the meal\n    // meal.seasonal_fruit = String::from("blueberries");\n}\n')),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"pub toast")," field can be read and written outside of the ",(0,o.kt)("inlineCode",{parentName:"p"},"back_of_house")," module, but the private ",(0,o.kt)("inlineCode",{parentName:"p"},"seasonal_fruit")," cannot. Note that the existence of this private field implies that other modules won't be able to create a new instance of ",(0,o.kt)("inlineCode",{parentName:"p"},"Breakfast"),", since they won't be able to set this private field. Here we've created a public associated function called ",(0,o.kt)("inlineCode",{parentName:"p"},"summer")," to act as a sort of constructor."),(0,o.kt)("p",null,"Enums behave exactly the opposite to structs. When we make an enum ",(0,o.kt)("inlineCode",{parentName:"p"},"pub"),", all of it's variants and all fields defined on all variants are automatically ",(0,o.kt)("inlineCode",{parentName:"p"},"pub")," as well."),(0,o.kt)("h2",{id:"74---bringing-paths-into-scope-with-the-use-keyword"},"7.4 - Bringing Paths into Scope with the ",(0,o.kt)("inlineCode",{parentName:"h2"},"use")," Keyword"),(0,o.kt)("p",null,"We've already seen many examples of using the ",(0,o.kt)("inlineCode",{parentName:"p"},"use")," keyword to bring something into scope. We can use it with modules within our crate to bring members from a child module into scope, too:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"use crate::front_of_house::hosting;\n\nmod front_of_house {\n    pub mod hosting {\n        pub fn add_to_waitlist() {}\n    }\n}\n\npub fn eat_at_restaurant() {\n    // Don't need to write `front_of_house::hosting::add_to_waitlist()`\n    // here because we brought `hosting` into scope with the `use`\n    // above.use crate::front_of_house::hosting;\n\n    hosting::add_to_waitlist();\n}\n")),(0,o.kt)("p",null,"You can think about ",(0,o.kt)("inlineCode",{parentName:"p"},"use")," a bit like a symbolic link in a file system, or a bit like JavaScript's ",(0,o.kt)("inlineCode",{parentName:"p"},"import { add_to_waitlist } from './hosting.js'"),". It adds a symbol to the scope of the ",(0,o.kt)("inlineCode",{parentName:"p"},"use")," statement."),(0,o.kt)("p",null,"One thing to note about modules is that, whether they're split into another file or used inline, the ",(0,o.kt)("inlineCode",{parentName:"p"},"mod")," keyword always creates a new scope that doesn't inherit anything from the parent scope. When we create a scope using braces, in most cases we assume all symbols from outside those braces will be available in the child scope. For example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'fn say_hello() {\n    let name = "Jason",\n\n    {\n        println!("Hello {}!", name);\n    }\n}\n')),(0,o.kt)("p",null,"Here ",(0,o.kt)("inlineCode",{parentName:"p"},"name")," is visible inside the scope created by the inner braces. The scope created by ",(0,o.kt)("inlineCode",{parentName:"p"},"mod")," however doesn't bring in anything from the parent scope:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"mod front_of_house {\n    mod serving {\n        fn serve_order() {}\n    }\n\n    pub mod hosting {\n        fn seat_at_table() {\n            // This won't compile!  `serving` is undefined here,\n            // even though it was defined one scope up.\n            serving::server_order();\n        }\n    }\n}\n")),(0,o.kt)("p",null,"This also means a ",(0,o.kt)("inlineCode",{parentName:"p"},"use")," statement at the top level of a file will only bring a symbol into scope for the top-level module, and not for any inline modules. If you want to ",(0,o.kt)("inlineCode",{parentName:"p"},"use")," a symbol inside an inline ",(0,o.kt)("inlineCode",{parentName:"p"},"mod"),", you'll need to put the ",(0,o.kt)("inlineCode",{parentName:"p"},"use")," inside that module:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"use crate::front_of_house::hosting;\n\n\nmod front_of_house {\n    pub mod hosting {\n        pub fn add_to_waitlist() {}\n    }\n}\n\n\nmod customer {\n    // We need this `use` here, even though we're already\n    // `use`ing hosting at the top level, because\n    // `mod customer` creates a new scope that doesn't\n    // inherit any symbols.\n    use crate::front_of_house::hosting;\n\n    pub fn eat_at_restaurant() {\n        hosting::add_to_waitlist();\n    }\n}\n")),(0,o.kt)("p",null,"This seems a bit strange at first, but it makes sense when you realize that modules are generally intended to be split across multiple files."),(0,o.kt)("h3",{id:"creating-idiomatic-use-paths"},"Creating Idiomatic use Paths"),(0,o.kt)("p",null,"These two listings do the same thing:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"// Version 1\nuse crate::front_of_house::hosting;\nfn fn1() {\n    hosting::add_to_waitlist();\n}\n\n// Version 2\nuse crate::front_of_house::hosting::add_to_waitlist;\nfn fn2() {\n    add_to_waitlist();\n}\n")),(0,o.kt)("p",null,"But the first one is considered idiomatic and the second is not. Generally we ",(0,o.kt)("inlineCode",{parentName:"p"},"use")," a module, and don't ",(0,o.kt)("inlineCode",{parentName:"p"},"use")," individual functions within a module. This makes for more typing, because we need to type the name of the module, but it also makes it clear that the function comes from some other module and isn't defined locally."),(0,o.kt)("p",null,"On the other hand, when bringing structs and enums into scope, we generally ",(0,o.kt)("inlineCode",{parentName:"p"},"use")," the individual struct or enum instead of the parent module. For example, we ",(0,o.kt)("inlineCode",{parentName:"p"},"use std::collections::HashMap;"),", and then just type ",(0,o.kt)("inlineCode",{parentName:"p"},"HashMap"),"."),(0,o.kt)("p",null,"If you want to use two data types from different modules that have the same name, you can either refer to them by their namespace:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"use std::fmt;\nuse std::io;\n\nfn fn1() -> fmt::Result {...}\nfn fn2() -> io::Result {...}\n")),(0,o.kt)("p",null,"Or you can use the ",(0,o.kt)("inlineCode",{parentName:"p"},"as")," keyword to rename a symbol:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"use std::fmt::Result as FmtResult;\nuse std::io::Result as IoResult;\n\nfn fn1() -> FmtResult {...}\nfn fn2() -> IoResult {...}\n")),(0,o.kt)("h3",{id:"re-exporting-names-with-pub-use"},"Re-exporting Names with ",(0,o.kt)("inlineCode",{parentName:"h3"},"pub use")),(0,o.kt)("p",null,'You can "re-export" a symbol from some other module in your module:'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'mod colors {\n    pub struct Color {\n        red: u8,\n        green: u8,\n        blue: u8,\n    }\n}\n\nmod ansi {\n    pub fn color_string(message: &str, color: crate::colors::Color) -> String {\n        // --snip--\n    }\n\n    pub use crate::colors::Color;\n}\n\nfn log_error(message: &str) {\n    let red = ansi::Color{red: 255, green: 0, blue: 0};\n    println!("{}", ansi::color_string(message, red));\n}\n')),(0,o.kt)("p",null,"Here callers of ",(0,o.kt)("inlineCode",{parentName:"p"},"ansi")," can use ",(0,o.kt)("inlineCode",{parentName:"p"},"ansi::Color"),", even though ",(0,o.kt)("inlineCode",{parentName:"p"},"Color")," us actually defined in the ",(0,o.kt)("inlineCode",{parentName:"p"},"colors")," module."),(0,o.kt)("h3",{id:"using-external-packages"},"Using External Packages"),(0,o.kt)("p",null,"Many useful crates are published on ",(0,o.kt)("a",{parentName:"p",href:"https://crates.io/"},"crates.io"),', and we can use these by adding them to the "dependencies" section of ',(0,o.kt)("em",{parentName:"p"},"cargo.toml"),". We did this back in ",(0,o.kt)("a",{parentName:"p",href:"/ch02-guessing-game",title:"Chapter 2: Guessing Game"},"chapter 2")," when we built our guessing game. There we added the ",(0,o.kt)("inlineCode",{parentName:"p"},"rand")," crate:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-toml"},'rand = "0.8.5"\n')),(0,o.kt)("p",null,"And then we ",(0,o.kt)("inlineCode",{parentName:"p"},"use"),"d the ",(0,o.kt)("inlineCode",{parentName:"p"},"Rng")," trait from rand:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"use rand::Rng;\n\nfn main() {\n    let secret_number = rand::thread_rng().gen_range(1..=100);\n}\n")),(0,o.kt)("h3",{id:"using-nested-paths-to-clean-up-large-use-lists"},"Using Nested Paths to Clean Up Large use Lists"),(0,o.kt)("p",null,"These two sets of use statements are equivalent:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"// This:\nuse std::cmp::Ordering;\nuse std::io;\n\n\n// Can be shortened to this:\nuse std::{cmp::Ordering, io};\n")),(0,o.kt)("p",null,"There's no difference between these, the second is just shorter. If we want to ",(0,o.kt)("inlineCode",{parentName:"p"},"use")," a module and some members of that module, we can use the ",(0,o.kt)("inlineCode",{parentName:"p"},"self")," keyword:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"// This:\nuse std::io;\nuse std::io::Write;\n\n\n// Can be shortened to this:\nuse std::io::{self, Write};\n")),(0,o.kt)("h3",{id:"the-glob-operator"},"The Glob Operator"),(0,o.kt)("p",null,"This will do exactly what you think it will:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"use std::collections::*;\n")),(0,o.kt)("p",null,"This brings all public symbols in the ",(0,o.kt)("inlineCode",{parentName:"p"},"std::collections")," module into scope. This is frequently used when writing tests, to bring everything in a module into scope in the test. We'll talk more about testing in ",(0,o.kt)("a",{parentName:"p",href:"/ch11-automated-tests",title:"Chapter 11: Writing Automated Tests"},"chapter 11"),"."),(0,o.kt)("h2",{id:"separating-modules-into-different-files"},"Separating Modules into Different Files"),(0,o.kt)("p",null,"We've used the inline style for modules in this chapter because we've been working with short examples, but in real life any non-trivial program is probably going to be split across multiple files:"),(0,o.kt)("p",null,"In ",(0,o.kt)("em",{parentName:"p"},"src/lib.rs"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"mod front_of_house;\n\npub use crate::front_of_house;\n\npub fn eat_at_restaurant() {\n    front_of_house::add_to_waitlist();\n}\n")),(0,o.kt)("p",null,"And then in ",(0,o.kt)("em",{parentName:"p"},"src/front_of_house.rs"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"pub fn add_to_waitlist() {}\n")),(0,o.kt)("p",null,"You only need to load a file with ",(0,o.kt)("inlineCode",{parentName:"p"},"mod")," once in your entire module tree, not in every place it is ",(0,o.kt)("inlineCode",{parentName:"p"},"use"),"d. ",(0,o.kt)("inlineCode",{parentName:"p"},"mod")," is not like ",(0,o.kt)("inlineCode",{parentName:"p"},"include")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"import")," from other programming languages."),(0,o.kt)("p",null,"Note that it's perfectly acceptable to have a small module be defined inline. You can always move it into its own file later if it grows. Since the path of a symbol doesn't change based on whether a module is inline or in a separate file, moving inline code into files doesn't require any refactoring work."),(0,o.kt)("p",null,"Continue to ",(0,o.kt)("a",{parentName:"p",href:"/ch08-common-collections",title:"Chapter 8: Common Collections"},"chapter 8"),"."))}m.isMDXComponent=!0}}]);