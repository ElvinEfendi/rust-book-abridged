"use strict";(self.webpackChunkrust_book_abridged=self.webpackChunkrust_book_abridged||[]).push([[3392],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>d});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),m=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=m(e.components);return a.createElement(s.Provider,{value:t},e.children)},u="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),u=m(n),h=r,d=u["".concat(s,".").concat(h)]||u[h]||c[h]||i;return n?a.createElement(d,o(o({ref:t},p),{},{components:n})):a.createElement(d,o({ref:t},p))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=h;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[u]="string"==typeof e?e:r,o[1]=l;for(var m=2;m<i;m++)o[m]=n[m];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},6688:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>c,frontMatter:()=>i,metadata:()=>l,toc:()=>m});var a=n(7462),r=(n(7294),n(3905));const i={},o="10.2 - Traits: Defining Shared Behavior",l={unversionedId:"ch10/ch10-02-traits",id:"ch10/ch10-02-traits",title:"10.2 - Traits: Defining Shared Behavior",description:"A trait in Rust is very similar to what most other languages call an interface. A trait defines some set of behavior, and every struct that implements the trait needs to implement that behavior.",source:"@site/docs/ch10/ch10-02-traits.md",sourceDirName:"ch10",slug:"/ch10/ch10-02-traits",permalink:"/rust-book-abridged/ch10/ch10-02-traits",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/ch10/ch10-02-traits.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"10.1 - Generic Data Types",permalink:"/rust-book-abridged/ch10/ch10-01-generic-data-types"},next:{title:"10.3 - Validating References with Lifetimes",permalink:"/rust-book-abridged/ch10/ch10-03-lifetimes"}},s={},m=[{value:"Defining a Trait",id:"defining-a-trait",level:2},{value:"Implementing a Trait on a Type",id:"implementing-a-trait-on-a-type",level:2},{value:"Default Implementations",id:"default-implementations",level:2},{value:"Traits as Parameters",id:"traits-as-parameters",level:2},{value:"Returning Types that Implement Traits",id:"returning-types-that-implement-traits",level:2},{value:"Using Trait Bounds to Conditionally Implement Methods",id:"using-trait-bounds-to-conditionally-implement-methods",level:2}],p={toc:m},u="wrapper";function c(e){let{components:t,...n}=e;return(0,r.kt)(u,(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"102---traits-defining-shared-behavior"},"10.2 - Traits: Defining Shared Behavior"),(0,r.kt)("p",null,"A ",(0,r.kt)("em",{parentName:"p"},"trait")," in Rust is very similar to what most other languages call an interface. A trait defines some set of behavior, and every struct that implements the trait needs to implement that behavior."),(0,r.kt)("h2",{id:"defining-a-trait"},"Defining a Trait"),(0,r.kt)("p",null,"Let's suppose we have two types, ",(0,r.kt)("inlineCode",{parentName:"p"},"Tweet")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"NewsArticle"),". We might want to be able to get a summary of tweet, and we might want to be able to get a summary of a news article, so it would make sense for both of these to implement a ",(0,r.kt)("inlineCode",{parentName:"p"},"summarize()")," function. We can define a trait called ",(0,r.kt)("inlineCode",{parentName:"p"},"Summary")," that defines the method signature that these types will need to implement:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"pub trait Summary {\n    fn summarize(&self) -> String;\n}\n")),(0,r.kt)("p",null,"Note that the trait only defines the method signatures - the contract, if you will - that the types need to implement. Each type is free to implement this function differently."),(0,r.kt)("h2",{id:"implementing-a-trait-on-a-type"},"Implementing a Trait on a Type"),(0,r.kt)("p",null,'In languages like TypeScript and Go, if we have an interface, and we have a type that defines all the same methods that the interface declares, then the type implements that interface. There\'s no need to explicitly mark that the type implements the interface. This is called "duck typing", because, as the saying goes, "if it walks like a duck, and it quacks like a duck, then it must be a duck."'),(0,r.kt)("p",null,"Not so in Rust. Here we must explicitly declare that a type implements a trait. The syntax is ",(0,r.kt)("inlineCode",{parentName:"p"},"impl [TRAIT] for [STRUCT] {}"),", and inside the curly braces we place all the methods we wish to implement:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'pub struct NewsArticle {\n    pub headline: String,\n    pub location: String,\n    pub author: String,\n    pub content: String,\n}\n\nimpl Summary for NewsArticle {\n    fn summarize(&self) -> String {\n        format!("{}, by {} ({})", self.headline, self.author, self.location)\n    }\n}\n\npub struct Tweet {\n    pub username: String,\n    pub content: String,\n    pub reply: bool,\n    pub retweet: bool,\n}\n\nimpl Summary for Tweet {\n    fn summarize(&self) -> String {\n        format!("{}: {}", self.username, self.content)\n    }\n}\n')),(0,r.kt)("p",null,"This is very similar to defining a method on the struct directly, but the method is actually defined on the trait. If we want to call the ",(0,r.kt)("inlineCode",{parentName:"p"},"summarize")," function, we need to make sure the trait is in scope. In this example we have to ",(0,r.kt)("inlineCode",{parentName:"p"},"use")," both ",(0,r.kt)("inlineCode",{parentName:"p"},"Summary")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Tweet"),", even though ",(0,r.kt)("inlineCode",{parentName:"p"},"Summary")," never appears in the code:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'use aggregator::{Summary, Tweet};\n\nfn main() {\n    let tweet = Tweet {\n        username: String::from("horse_ebooks"),\n        content: String::from(\n            "of course, as you probably already know, people",\n        ),\n        reply: false,\n        retweet: false,\n    };\n\n    println!("1 new tweet: {}", tweet.summarize());\n}\n')),(0,r.kt)("p",null,"Other crates can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"Summary")," trait and implement it on their own types, just like you can implement traits from the standard library on your own types. One thing to note is that if you want to implement a trait on a type, then either the trait or the type (or both) must be local to your crate. You can't use a trait from one external crate, a type from another, and then implement the external trait on the external type in your crate."),(0,r.kt)("p",null,"This restriction is in place because of something called the ",(0,r.kt)("em",{parentName:"p"},"orphan rule"),". Basically the problem is that if you did this in your library crate, and I did the same thing for the same two types in my library crate, then if a project tried to use both our library crates there would be two different implementations for the same trait and type, and Rust would have no way of knowing which was correct."),(0,r.kt)("h2",{id:"default-implementations"},"Default Implementations"),(0,r.kt)("p",null,"Remember how we said a trait just had signatures and no implementations? Well, sometimes it's handy to be able to define default behavior for a method:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'pub trait Summary {\n    fn summarize(&self) -> String {\n        String::from("(Read more...)")\n    }\n}\n\n// We can implement this trait with an empty\n// impl block, taking the default function\n// definitions.\nimpl Summary for NewsArticle {}\n')),(0,r.kt)("p",null,"Default implementations are allowed to call other methods on the trait. This allows a trait to provide a lot of functionality while only requiring implementers to implement part of the trait:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'pub trait Summary {\n    fn summarize_author(&self) -> String;\n\n    fn summarize(&self) -> String {\n        format!("(Read more from {}...)", self.summarize_author())\n    }\n}\n')),(0,r.kt)("p",null,"Some implementations might only implement ",(0,r.kt)("inlineCode",{parentName:"p"},"summarize_author()"),", while some might implement both methods."),(0,r.kt)("h2",{id:"traits-as-parameters"},"Traits as Parameters"),(0,r.kt)("p",null,"We can use a trait as a type for a function parameter or variable using the ",(0,r.kt)("inlineCode",{parentName:"p"},"impl")," keyword:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'pub fn notify(item: &impl Summary) {\n    println!("Breaking news! {}", item.summarize());\n}\n')),(0,r.kt)("p",null,"This is actually syntactic sugar for ",(0,r.kt)("em",{parentName:"p"},"trait bound")," syntax:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'pub fn notify<T: Summary>(item: &T) {\n    println!("Breaking news! {}", item.summarize());\n}\n')),(0,r.kt)("p",null,"Here we're declaring a generic function, but we're setting bounds on the type of T. Whatever you pass in for T has to satisfy the ",(0,r.kt)("inlineCode",{parentName:"p"},"Summary")," trait. We can specify more than one trait bound:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"// Using the `impl` syntax:\npub fn notify(item: &(impl Summary + Display)) {...}\n\n// Using a trait bound:\npub fn notify<T: Summary + Display>(item: &T) {...}\n")),(0,r.kt)("p",null,"Here whatever we pass in for ",(0,r.kt)("inlineCode",{parentName:"p"},"T")," must satisfy both our own ",(0,r.kt)("inlineCode",{parentName:"p"},"Summary")," trait and the ",(0,r.kt)("inlineCode",{parentName:"p"},"Display")," trait from the standard library (so we can use ",(0,r.kt)("inlineCode",{parentName:"p"},"{}")," to display the item with ",(0,r.kt)("inlineCode",{parentName:"p"},"println!")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"format!"),")."),(0,r.kt)("p",null,"This can get a bit hard to read if you have a lot of traits bounds. There ends up being a lot of clutter between the name of the function and the parameters. Borrowing a page from SQL, we can also write trait bounds using the ",(0,r.kt)("inlineCode",{parentName:"p"},"with")," syntax. These two examples are equivalent:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"fn some_function<T: Display + Clone, U: Clone + Debug>(t: &T, u: &U) -> i32 {...}\n\nfn some_function<T, U>(t: &T, u: &U) -> i32\nwhere\n    T: Display + Clone,\n    U: Clone + Debug,\n{...}\n")),(0,r.kt)("h2",{id:"returning-types-that-implement-traits"},"Returning Types that Implement Traits"),(0,r.kt)("p",null,"In addition to using traits as parameters, we can of course also return them. This lets us hide the concrete type from the caller:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'fn returns_summarizable() -> impl Summary {\n    Tweet {\n        username: String::from("horse_ebooks"),\n        content: String::from(\n            "of course, as you probably already know, people",\n        ),\n        reply: false,\n        retweet: false,\n    }\n}\n')),(0,r.kt)("p",null,"Specifying a trait as a return type can also be very handy when using closures and iterators. Sometimes when using an iterator, the type inferred by the compiler can be quite long, and writing the full type out by hand would be a lot of work without much benefit. Being able to supply a trait here is much more concise."),(0,r.kt)("p",null,"If you're coming from another language, you might think that ",(0,r.kt)("inlineCode",{parentName:"p"},"returns_summarizable()")," would be able to return a ",(0,r.kt)("inlineCode",{parentName:"p"},"Tweet")," in one branch and a ",(0,r.kt)("inlineCode",{parentName:"p"},"NewsArticle")," in another, but it can't. This restriction is imposed by how this is implemented in the compiler. We'll see how to overcome this in ",(0,r.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch17-object-oriented-features#172---using-trait-objects-that-allow-for-values-of-different-types"},"chapter 17"),"."),(0,r.kt)("h2",{id:"using-trait-bounds-to-conditionally-implement-methods"},"Using Trait Bounds to Conditionally Implement Methods"),(0,r.kt)("p",null,"As we saw ",(0,r.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch10/ch10-01-generic-data-types#in-method-definitions"},"earlier"),", we can specify an implementation for a method on specific types of a generic type. We can similarly implement a method on specific trait bounds:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'use std::fmt::Display;\n\nstruct Pair<T> {\n    x: T,\n    y: T,\n}\n\nimpl<T> Pair<T> {\n    fn new(x: T, y: T) -> Self {\n        Self { x, y }\n    }\n}\n\nimpl<T: Display + PartialOrd> Pair<T> {\n    fn cmp_display(&self) {\n        if self.x >= self.y {\n            println!("The largest member is x = {}", self.x);\n        } else {\n            println!("The largest member is y = {}", self.y);\n        }\n    }\n}\n')),(0,r.kt)("p",null,"Here the ",(0,r.kt)("inlineCode",{parentName:"p"},"new()")," associated function is implemented on all generic types, but ",(0,r.kt)("inlineCode",{parentName:"p"},"cmp_display()")," is only defined on a ",(0,r.kt)("inlineCode",{parentName:"p"},"Pair<T>")," if the inner type used for T implements both the ",(0,r.kt)("inlineCode",{parentName:"p"},"Display")," and the ",(0,r.kt)("inlineCode",{parentName:"p"},"PartialOrd")," traits."),(0,r.kt)("p",null,"We can also conditionally implement a trait for any type that implements some other trait! These are called ",(0,r.kt)("em",{parentName:"p"},"blanket implementations"),". This example comes from the standard library:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"impl<T: Display> ToString for T {\n    // --snip--\n}\n")),(0,r.kt)("p",null,"Because of this, we can call ",(0,r.kt)("inlineCode",{parentName:"p"},"to_string()")," on any type that implements the ",(0,r.kt)("inlineCode",{parentName:"p"},"Display")," trait."))}c.isMDXComponent=!0}}]);