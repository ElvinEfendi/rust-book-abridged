"use strict";(self.webpackChunkrust_book_abridged=self.webpackChunkrust_book_abridged||[]).push([[7915],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>h});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},m="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),m=p(n),u=r,h=m["".concat(s,".").concat(u)]||m[u]||d[u]||i;return n?a.createElement(h,o(o({ref:t},c),{},{components:n})):a.createElement(h,o({ref:t},c))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[m]="string"==typeof e?e:r,o[1]=l;for(var p=2;p<i;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},6983:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>l,toc:()=>p});var a=n(7462),r=(n(7294),n(3905));const i={},o="15 - Smart Pointers",l={unversionedId:"ch15-smart-pointers",id:"ch15-smart-pointers",title:"15 - Smart Pointers",description:"In C++, whenever we want to store an object on the heap, we new that object to allocate some memory. At some later point in time, we have to delete that memory. This is much like malloc and free in standard C.",source:"@site/docs/ch15-smart-pointers.md",sourceDirName:".",slug:"/ch15-smart-pointers",permalink:"/rust-book-abridged/ch15-smart-pointers",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/ch15-smart-pointers.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"14 - More about Cargo and Crates",permalink:"/rust-book-abridged/ch14-more-about-cargo"},next:{title:"16 - Fearless Concurrency",permalink:"/rust-book-abridged/ch16-fearless-concurrency"}},s={},p=[{value:"15.1 - Using <code>Box&lt;T&gt;</code> to Point to Data on the Heap",id:"151---using-boxt-to-point-to-data-on-the-heap",level:2},{value:"Enabling Recursive Types with Boxes",id:"enabling-recursive-types-with-boxes",level:3},{value:"15.2 Treating Smart Pointers Like Regular References with the Deref Trait",id:"152-treating-smart-pointers-like-regular-references-with-the-deref-trait",level:2},{value:"Following the Pointer to the Value",id:"following-the-pointer-to-the-value",level:3},{value:"Using <code>Box&lt;T&gt;</code> Like a Reference",id:"using-boxt-like-a-reference",level:3},{value:"Defining Our Own Smart Pointer",id:"defining-our-own-smart-pointer",level:3},{value:"Implicit Deref Coercions with Functions and Methods",id:"implicit-deref-coercions-with-functions-and-methods",level:3},{value:"How Deref Coercion Interacts with Mutability",id:"how-deref-coercion-interacts-with-mutability",level:3},{value:"15.3 - Running Code on Cleanup with the <code>Drop</code> trait",id:"153---running-code-on-cleanup-with-the-drop-trait",level:2},{value:"Dropping a Value Early with <code>std::mem::drop</code>",id:"dropping-a-value-early-with-stdmemdrop",level:3},{value:"15.4 - <code>Rc&lt;T&gt;</code>, the Reference Counted Smart Pointer",id:"154---rct-the-reference-counted-smart-pointer",level:2},{value:"Using <code>Rc&lt;T&gt;</code> to Share Data",id:"using-rct-to-share-data",level:3},{value:"15.5 - <code>RefCell&lt;T&gt;</code> and the Interior Mutability Pattern",id:"155---refcellt-and-the-interior-mutability-pattern",level:2},{value:"A Use Case for Interior Mutability: Mock Objects",id:"a-use-case-for-interior-mutability-mock-objects",level:3},{value:"Having Multiple Owners of Mutable Data by Combining <code>Rc&lt;T&gt;</code> and <code>RefCell&lt;T&gt;</code>",id:"having-multiple-owners-of-mutable-data-by-combining-rct-and-refcellt",level:3},{value:"15.6 - Reference Cycles Can Leak Memory",id:"156---reference-cycles-can-leak-memory",level:2},{value:"Creating a Reference Cycle",id:"creating-a-reference-cycle",level:3},{value:"Preventing Reference Cycles: Turning an <code>Rc&lt;T&gt;</code> into a <code>Weak&lt;T&gt;</code>",id:"preventing-reference-cycles-turning-an-rct-into-a-weakt",level:3}],c={toc:p},m="wrapper";function d(e){let{components:t,...n}=e;return(0,r.kt)(m,(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"15---smart-pointers"},"15 - Smart Pointers"),(0,r.kt)("p",null,"In C++, whenever we want to store an object on the heap, we ",(0,r.kt)("inlineCode",{parentName:"p"},"new")," that object to allocate some memory. At some later point in time, we have to ",(0,r.kt)("inlineCode",{parentName:"p"},"delete")," that memory. This is much like ",(0,r.kt)("inlineCode",{parentName:"p"},"malloc")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"free")," in standard C."),(0,r.kt)("p",null,'C++ has a few different "smart pointers" that will delete that memory for you at the appropriate time. The most commonly used is probably ',(0,r.kt)("inlineCode",{parentName:"p"},"shared_ptr"),', which keeps a "reference count". Every time your copy a ',(0,r.kt)("inlineCode",{parentName:"p"},"shared_ptr")," it increments the reference count, and every time one is destroyed it decrements the count. Once the count reaches 0, ",(0,r.kt)("inlineCode",{parentName:"p"},"shared_ptr")," knows there are no more references to the underlying memory it is safe to be freed."),(0,r.kt)("p",null,"Rust has a variety of smart pointer objects as well, which allow us to store values on the heap, including ",(0,r.kt)("inlineCode",{parentName:"p"},"Rc<T>")," which works much like ",(0,r.kt)("inlineCode",{parentName:"p"},"shared_ptr")," and allows us to share ownership of a value across multiple variables in code. This chapter will explore a few of the different smart pointer implementations in Rust and where you might want to use them."),(0,r.kt)("p",null,"Smart pointers in Rust generally implement the ",(0,r.kt)("inlineCode",{parentName:"p"},"Drop")," trait (so they can run some custom code when they are dropped, like decrementing a reference count) and the ",(0,r.kt)("inlineCode",{parentName:"p"},"Deref")," trait (which lets a smart pointer be used in place of a reference to the underlying value)."),(0,r.kt)("h2",{id:"151---using-boxt-to-point-to-data-on-the-heap"},"15.1 - Using ",(0,r.kt)("inlineCode",{parentName:"h2"},"Box<T>")," to Point to Data on the Heap"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Box<T>"),' is not a very exciting smart pointer. It\'s perhaps the "least smart" of the smart pointers. ',(0,r.kt)("inlineCode",{parentName:"p"},"Box<T>")," lets us store a single piece of data on the heap instead of on the stack:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="src/main.rs"',title:'"src/main.rs"'},'fn main() {\n    let b = Box::new(5);\n    println!("b = {}", b);\n}\n')),(0,r.kt)("p",null,'Here "5" gets stored as four bytes on the heap instead of as four bytes on the stack. Notice that we can use ',(0,r.kt)("inlineCode",{parentName:"p"},"b")," exactly like a ",(0,r.kt)("inlineCode",{parentName:"p"},"&i32")," when we pass it to ",(0,r.kt)("inlineCode",{parentName:"p"},"println!"),"."),(0,r.kt)("p",null,"Why would we want to do this, though? When we're passing data around on the stack, Rust has to know the size of that data at compile time. When we pass an ",(0,r.kt)("inlineCode",{parentName:"p"},"i32")," as a parameter, for example, Rust knows that it's going to need 4 bytes on the stack to hold that parameter. But sometimes we don't know the size of a value ahead of time, and this is where ",(0,r.kt)("inlineCode",{parentName:"p"},"Box<T>")," is useful - examples would be recursive data structures (which can be \"infinitely\" large since they can contain more of themselves) and trait objects, where we want to claim that a parameter implements a specific trait but we don't care what concrete type the parameter is (we'll talk more about these in ",(0,r.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch17-object-oriented-features#172---using-trait-objects-that-allow-for-values-of-different-types"},"chapter 17"),")."),(0,r.kt)("p",null,"In these cases, instead of passing the value directly on the stack, we pass the ",(0,r.kt)("inlineCode",{parentName:"p"},"Box<T>")," on the stack and put the unknown-sized value on the heap."),(0,r.kt)("p",null,"Another example where ",(0,r.kt)("inlineCode",{parentName:"p"},"Box<T>")," would be useful is where you have some particularly large piece of data that you want to pass around. Values passed on the stack are passed-by-copy, and copying large amounts of data can be inefficient. Storing the data on the heap lets us pass around copies of the relatively small ",(0,r.kt)("inlineCode",{parentName:"p"},"Box<T>")," instead."),(0,r.kt)("h3",{id:"enabling-recursive-types-with-boxes"},"Enabling Recursive Types with Boxes"),(0,r.kt)("p",null,"This is a data structure called the ",(0,r.kt)("em",{parentName:"p"},"cons list")," which we're going to borrow from lisp:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"enum List {\n    Cons(i32, List),\n    Nil,\n}\n")),(0,r.kt)("p",null,'This is sort of a "linked list", where each item is either an ',(0,r.kt)("inlineCode",{parentName:"p"},"i32"),' and a "next item on the list", or else is ',(0,r.kt)("inlineCode",{parentName:"p"},"Nil")," (to signify the end of the list). We could use this like:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"use List::{Cons, Nil}\n\nfn main() {\n    let list = Cons(1, Cons(2, Cons(3, Nil)));\n}\n")),(0,r.kt)("p",null,"This is probably not a data structure you'd actually want to use in Rust, but it's a recursive data structure that's convenient for this example. If you try to compile the above, it will fail, because Rust can't work out the size of the ",(0,r.kt)("inlineCode",{parentName:"p"},"list")," variable to store it on the stack."),(0,r.kt)("p",null,"For an enum, Rust will allocate enough memory to store the largest of the enum's variants. Here the largest is going to be ",(0,r.kt)("inlineCode",{parentName:"p"},"Cons"),", which can hold an ",(0,r.kt)("inlineCode",{parentName:"p"},"i32")," and a ",(0,r.kt)("inlineCode",{parentName:"p"},"List"),", so it's four bytes long plus the size of a ",(0,r.kt)("inlineCode",{parentName:"p"},"List"),". But this is a recursive definition - ",(0,r.kt)("inlineCode",{parentName:"p"},"sizeof(List) = 4 + sizeof(List)"),". This makes ",(0,r.kt)("inlineCode",{parentName:"p"},"rustc")," unhappy."),(0,r.kt)("p",null,"The solution is to move this to the heap:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="src/main.rs"',title:'"src/main.rs"'},"use List::{Cons, Nil}\n\nenum List {\n    Cons(i32, Box<List>),\n    Nil,\n}\n\nfn main() {\n    let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));\n}\n")),(0,r.kt)("p",null,"Now ",(0,r.kt)("inlineCode",{parentName:"p"},"sizeof(Cons) = 4 + sizeof(Box<List>)"),", and the size of ",(0,r.kt)("inlineCode",{parentName:"p"},"Box<List>")," doesn't depend on the size of ",(0,r.kt)("inlineCode",{parentName:"p"},"<List>")," (since that part is stored on the heap), so this is something we can work out."),(0,r.kt)("h2",{id:"152-treating-smart-pointers-like-regular-references-with-the-deref-trait"},"15.2 Treating Smart Pointers Like Regular References with the Deref Trait"),(0,r.kt)("p",null,"In this section we're going to implement our own smart pointer called ",(0,r.kt)("inlineCode",{parentName:"p"},"MyBox"),". Our smart pointer won't actually store anything on the heap, it will just store things on the stack, because what we really want to do here is explore the ",(0,r.kt)("inlineCode",{parentName:"p"},"Deref")," trait."),(0,r.kt)("h3",{id:"following-the-pointer-to-the-value"},"Following the Pointer to the Value"),(0,r.kt)("p",null,"Before we talk about ",(0,r.kt)("inlineCode",{parentName:"p"},"Deref"),", let's talk about what we mean by dereferencing."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="src/main.rs"',title:'"src/main.rs"'},"fn main() {\n    let x = 5;\n    let y = &x;\n\n    assert_eq!(5, x);\n    assert_eq!(5, *y);\n}\n")),(0,r.kt)("p",null,"Here ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," is of type ",(0,r.kt)("inlineCode",{parentName:"p"},"i32"),", but ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," is of type ",(0,r.kt)("inlineCode",{parentName:"p"},"&i32"),". ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," is essentially a pointer to ",(0,r.kt)("inlineCode",{parentName:"p"},"x"),". We can assert that x is equal to 5, but in order to get to the value of ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," we have to ",(0,r.kt)("em",{parentName:"p"},"dereference")," it to get to the value that ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," points to."),(0,r.kt)("p",null,"If you're coming from a language like C or Go, this is probably second nature to you. If you're coming from JavaScript, this might be a new concept, so let me rewrite the above in Typescript, borrowing React's ",(0,r.kt)("inlineCode",{parentName:"p"},"Ref")," type:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="src/main.rs"',title:'"src/main.rs"'},"interface Ref<T> {\n  current: T;\n}\n\nfunction main() {\n  const x = 5;\n  const y = { current: x };\n\n  assert.equal(x, 5);\n  assert.equal(y.current, 5);\n}\n")),(0,r.kt)("p",null,"In our Rust example, the ",(0,r.kt)("inlineCode",{parentName:"p"},"*y")," is basically doing the same thing as ",(0,r.kt)("inlineCode",{parentName:"p"},"y.current")," in our TypeScript example. Rust will automatically dereference a value for you in many places, so the ",(0,r.kt)("inlineCode",{parentName:"p"},"*")," operator doesn't get much use in Rust, but there are places (like in this example) where it is required."),(0,r.kt)("h3",{id:"using-boxt-like-a-reference"},"Using ",(0,r.kt)("inlineCode",{parentName:"h3"},"Box<T>")," Like a Reference"),(0,r.kt)("p",null,"Because ",(0,r.kt)("inlineCode",{parentName:"p"},"Box<T>")," implements ",(0,r.kt)("inlineCode",{parentName:"p"},"Deref"),", we can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"*")," operator on it, and treat it just like a reference. This (combined with a Rust feature called ",(0,r.kt)("em",{parentName:"p"},"deref coercion"),") means that any function that takes a ",(0,r.kt)("inlineCode",{parentName:"p"},"&i32")," can also take a ",(0,r.kt)("inlineCode",{parentName:"p"},"Box<i32>"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="src/main.rs"',title:'"src/main.rs"'},"fn main() {\n    let x = 5;\n    let y = Box::new(x);\n\n    assert_eq!(5, x);\n    assert_eq!(5, *y);\n}\n")),(0,r.kt)("h3",{id:"defining-our-own-smart-pointer"},"Defining Our Own Smart Pointer"),(0,r.kt)("p",null,"Let's create our own smart pointer and learn how the ",(0,r.kt)("inlineCode",{parentName:"p"},"Deref"),' trait works. To do this we\'ll create a simple "pointer" that stores the value in a generic named tuple:'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"struct MyBox<T>(T);\n\nimpl<T> MyBox<T> {\n    fn new(x: T) -> MyBox<T> {\n        MyBox(x)\n    }\n}\n")),(0,r.kt)("p",null,"And then, in order to let us use the ",(0,r.kt)("inlineCode",{parentName:"p"},"*")," operator on ",(0,r.kt)("inlineCode",{parentName:"p"},"MyBox<T>"),", we implement the ",(0,r.kt)("inlineCode",{parentName:"p"},"Deref")," trait. This trait has only one required method we have to implement called ",(0,r.kt)("inlineCode",{parentName:"p"},"deref")," which borrows self and returns the inner value:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"use std::ops::Deref;\n\nimpl<T> Deref for MyBox<T> {\n    type Target = T;\n\n    fn deref(&self) -> &Self::Target {\n        &self.0\n    }\n}\n")),(0,r.kt)("p",null,"(Since many other languages don't have tuples, a quick reminder here that in the ",(0,r.kt)("inlineCode",{parentName:"p"},"deref")," method ",(0,r.kt)("inlineCode",{parentName:"p"},"self")," here is a tuple, so ",(0,r.kt)("inlineCode",{parentName:"p"},"self.0")," is the first (and only) element in the tuple, and ",(0,r.kt)("inlineCode",{parentName:"p"},"&self.0")," returns a reference to the first element in the tuple.)"),(0,r.kt)("p",null,"And now we can do:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="src/main.rs"',title:'"src/main.rs"'},"fn main() {\n    let x = 5;\n    let y = Box::new(x);\n\n    assert_eq!(5, x);\n    assert_eq!(5, *y);\n}\n")),(0,r.kt)("p",null,"When we write ",(0,r.kt)("inlineCode",{parentName:"p"},"*y")," here, what's actually happening is Rust is going to replace this with ",(0,r.kt)("inlineCode",{parentName:"p"},"*(y.deref())"),"."),(0,r.kt)("h3",{id:"implicit-deref-coercions-with-functions-and-methods"},"Implicit Deref Coercions with Functions and Methods"),(0,r.kt)("p",null,"We've noted before that you can pass a ",(0,r.kt)("inlineCode",{parentName:"p"},"&String")," to a function that expects a ",(0,r.kt)("inlineCode",{parentName:"p"},"&str"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="src/main.rs"',title:'"src/main.rs"'},'fn hello(name: &str) {\n    println!("Hello, {name}!");\n}\n\nfn main() {\n    let x = String::from("Rust");\n    hello(&x);\n}\n')),(0,r.kt)("p",null,"The reason this works is because of a feature called ",(0,r.kt)("em",{parentName:"p"},"deref coercion"),". If we pass a ref of the wrong type to a function, but that ref implements ",(0,r.kt)("inlineCode",{parentName:"p"},"Deref"),", then Rust will call ",(0,r.kt)("inlineCode",{parentName:"p"},"deref")," on the value (possibly more than once) to convert it to the correct type. For example, ",(0,r.kt)("inlineCode",{parentName:"p"},"String")," ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/rust-lang/rust/blob/b0884a3528c45a5d575e182f407c759d243fdcba/library/alloc/src/string.rs#L2442-L2450"},"implements the ",(0,r.kt)("inlineCode",{parentName:"a"},"Deref")," trait")," and returns a ",(0,r.kt)("inlineCode",{parentName:"p"},"&str"),", so we can convert ",(0,r.kt)("inlineCode",{parentName:"p"},"&String")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"&str"),"."),(0,r.kt)("p",null,"If we were to pass a ",(0,r.kt)("inlineCode",{parentName:"p"},"&MyBox<T>")," to the ",(0,r.kt)("inlineCode",{parentName:"p"},"foo")," function above, Rust would convert it to a ",(0,r.kt)("inlineCode",{parentName:"p"},"&String")," via ",(0,r.kt)("inlineCode",{parentName:"p"},"MyBox"),"'s ",(0,r.kt)("inlineCode",{parentName:"p"},"deref")," method, and then into a ",(0,r.kt)("inlineCode",{parentName:"p"},"&str")," via ",(0,r.kt)("inlineCode",{parentName:"p"},"String"),"'s ",(0,r.kt)("inlineCode",{parentName:"p"},"deref")," method."),(0,r.kt)("p",null,"If Rust didn't implement deref coercion, we'd have to write something like:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="src/main.rs"',title:'"src/main.rs"'},'fn main() {\n    let m = MyBox::new(String::from("Rust"));\n    hello(&(*m)[..]);\n}\n')),(0,r.kt)("p",null,"And no one wants to write that."),(0,r.kt)("h3",{id:"how-deref-coercion-interacts-with-mutability"},"How Deref Coercion Interacts with Mutability"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"Deref")," trait only works with immutable references, but there is also a ",(0,r.kt)("inlineCode",{parentName:"p"},"DerefMut")," trait for mutable references. Rust will do deref coercion in three cases:"),(0,r.kt)("p",null,"Rust does deref coercion when it finds types and trait implementations in three cases. If you have a ",(0,r.kt)("inlineCode",{parentName:"p"},"&T")," and you want an ",(0,r.kt)("inlineCode",{parentName:"p"},"&U"),", then if ",(0,r.kt)("inlineCode",{parentName:"p"},"T")," implements ",(0,r.kt)("inlineCode",{parentName:"p"},"Deref")," to type ",(0,r.kt)("inlineCode",{parentName:"p"},"U"),", then rust will take care of this for you, just like we saw above. The same is true if you have a ",(0,r.kt)("inlineCode",{parentName:"p"},"&mut T")," and want an ",(0,r.kt)("inlineCode",{parentName:"p"},"&mut U"),", but here the conversion will happen via the ",(0,r.kt)("inlineCode",{parentName:"p"},"DerefMut")," trait instead. If you want to mix these, if you have a ",(0,r.kt)("inlineCode",{parentName:"p"},"&mut T")," and you want a ",(0,r.kt)("inlineCode",{parentName:"p"},"&U"),", then Rust will use the ",(0,r.kt)("inlineCode",{parentName:"p"},"Deref")," trait on type ",(0,r.kt)("inlineCode",{parentName:"p"},"T")," to convert to a ",(0,r.kt)("inlineCode",{parentName:"p"},"U"),". Obviously ownership rules prevent Rust from automatically converting a ",(0,r.kt)("inlineCode",{parentName:"p"},"&T")," to a ",(0,r.kt)("inlineCode",{parentName:"p"},"&mut U"),"."),(0,r.kt)("h2",{id:"153---running-code-on-cleanup-with-the-drop-trait"},"15.3 - Running Code on Cleanup with the ",(0,r.kt)("inlineCode",{parentName:"h2"},"Drop")," trait"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"Drop")," trait allows us to specify some code that must be run whenever a struct is dropped (when it goes out of scope).  The ",(0,r.kt)("inlineCode",{parentName:"p"},"Drop")," trait is almost always used when implementing a smart pointer.  ",(0,r.kt)("inlineCode",{parentName:"p"},"Box<T>")," implements ",(0,r.kt)("inlineCode",{parentName:"p"},"Drop")," so it can clean up the memory it is using on the heap.  The ",(0,r.kt)("inlineCode",{parentName:"p"},"Rc<T>")," type (which will talk about in the ",(0,r.kt)("a",{parentName:"p",href:"#154---rct-the-reference-counted-smart-pointer"},"next section"),") implements ",(0,r.kt)("inlineCode",{parentName:"p"},"Drop")," so it can decrement the reference count."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Drop")," can also be used like ",(0,r.kt)("a",{parentName:"p",href:"https://en.cppreference.com/w/cpp/language/raii"},"RAII in C++"),".  If you have a struct that opens a network connection in its constructor, you can implement the ",(0,r.kt)("inlineCode",{parentName:"p"},"Drop")," trait to ensure the network connection is closed when the struct is dropped, ensuring you won't leak any resources."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"Drop")," trait is included in the prelude, and has only one required method named ",(0,r.kt)("inlineCode",{parentName:"p"},"drop"),".  Let's see an example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="src/main.rs"',title:'"src/main.rs"'},'struct CustomSmartPointer {\n    data: String,\n}\n\nimpl Drop for CustomSmartPointer {\n    fn drop(&mut self) {\n        println!("Dropping CustomSmartPointer with data `{}`!", self.data);\n    }\n}\n\nfn main() {\n    let c = CustomSmartPointer {\n        data: String::from("my stuff"),\n    };\n    let d = CustomSmartPointer {\n        data: String::from("other stuff"),\n    };\n    println!("CustomSmartPointers created.");\n}\n')),(0,r.kt)("p",null,"If you run this, you'll see the ",(0,r.kt)("inlineCode",{parentName:"p"},"drop")," method gets called automatically for ",(0,r.kt)("inlineCode",{parentName:"p"},"c")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"d")," when they get dropped at the end of ",(0,r.kt)("inlineCode",{parentName:"p"},"main"),"."),(0,r.kt)("h3",{id:"dropping-a-value-early-with-stdmemdrop"},"Dropping a Value Early with ",(0,r.kt)("inlineCode",{parentName:"h3"},"std::mem::drop")),(0,r.kt)("p",null,"Sometimes we may want to drop a value earlier than it would normally get dropped at the end of the scope.  For example, if we're using RAII to acquire some resource like a lock or a network connection, we may want to drop a value to release that resource before we reach the end of the function."),(0,r.kt)("p",null,"We cannot simply call the ",(0,r.kt)("inlineCode",{parentName:"p"},"drop")," method on a type, however, as the Rust compiler is going to call it for us, and we don't want to ",(0,r.kt)("em",{parentName:"p"},"double free")," any memory or resources by calling ",(0,r.kt)("inlineCode",{parentName:"p"},"drop")," twice.  Instead we can call ",(0,r.kt)("inlineCode",{parentName:"p"},"std::mem::drop"),", passing in the value we want to drop:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n    let c = CustomSmartPointer {\n        data: String::from("some data"),\n    };\n    println!("CustomSmartPointer created.");\n    drop(c);\n    println!("CustomSmartPointer dropped before the end of main.");\n}\n')),(0,r.kt)("h2",{id:"154---rct-the-reference-counted-smart-pointer"},"15.4 - ",(0,r.kt)("inlineCode",{parentName:"h2"},"Rc<T>"),", the Reference Counted Smart Pointer"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Rc<T>")," is a reference counting smart pointer (this is why it's named ",(0,r.kt)("inlineCode",{parentName:"p"},"Rc"),"), conceptually very similar to C++'s ",(0,r.kt)("inlineCode",{parentName:"p"},"shared_ptr"),". Note that ",(0,r.kt)("inlineCode",{parentName:"p"},"Rc<T>")," isn't thread safe - we'll talk about how to solve this problem in a multithreaded program in ",(0,r.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch16-fearless-concurrency",title:"Chapter 16: Fearless Concurrency"},"chapter 16"),"."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Rc<T>")," is used in the case where we have some data we want to use in multiple places, but we're not sure at compile time who is going to be finished with this data first."),(0,r.kt)("p",null,"If we model a graph as a collection of edges and nodes, then we might decide that an edge owns the nodes it connects to, but obviously any given node could connect to more than one edge, and in Rust any piece of data can only have one owner. But what we want want is for a node to be dropped once it's no longer attached to any edges."),(0,r.kt)("p",null,"The idea behind ",(0,r.kt)("inlineCode",{parentName:"p"},"Rc<T>")," is that it allocates some data on the heap and a counter on the heap, and sets that counter to 1. Whenever we make a copy of an ",(0,r.kt)("inlineCode",{parentName:"p"},"Rc<T>"),", the copy points to the same memory and the same counter, an increments the counter by one. Whenever an ",(0,r.kt)("inlineCode",{parentName:"p"},"Rc<T>")," is dropped, it decrements the counter by 1 and if the counter is 0 then it can safely free the memory on the heap. Each instance of ",(0,r.kt)("inlineCode",{parentName:"p"},"Rc<T>")," is only owned by one variable, just like normal Rust ownership rules, and since ",(0,r.kt)("inlineCode",{parentName:"p"},"Rc<T>")," is quite a small data structure - really just a pointer - it is quite inexpensive to copy, so we're free to copy it and have lots of owners."),(0,r.kt)("h3",{id:"using-rct-to-share-data"},"Using ",(0,r.kt)("inlineCode",{parentName:"h3"},"Rc<T>")," to Share Data"),(0,r.kt)("p",null,"Let's see a concrete example. Lets go back to our cons list, but we'll do something slightly unusual, and join three lists together:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="src/main.rs"',title:'"src/main.rs"'},"enum List {\n    Cons(i32, Box<List>),\n    Nil,\n}\n\nuse crate::List::{Cons, Nil};\n\nfn main() {\n    let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));\n    let b = Cons(3, Box::new(a));\n    let c = Cons(4, Box::new(a)); // This doesn't work!\n}\n")),(0,r.kt)("p",null,"We have list ",(0,r.kt)("inlineCode",{parentName:"p"},"a"),", and then we make this the tail of both list ",(0,r.kt)("inlineCode",{parentName:"p"},"b")," and list ",(0,r.kt)("inlineCode",{parentName:"p"},"c"),". The problem we're going to run into here is that the ",(0,r.kt)("inlineCode",{parentName:"p"},"Box<T>")," type owns the value we put in it, so when we create ",(0,r.kt)("inlineCode",{parentName:"p"},"b")," we move ",(0,r.kt)("inlineCode",{parentName:"p"},"a")," into a ",(0,r.kt)("inlineCode",{parentName:"p"},"Box<T>"),". When we try to create ",(0,r.kt)("inlineCode",{parentName:"p"},"c"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"a")," has already been moved, so we can't move it again."),(0,r.kt)("p",null,"We could fix this particular example with some lifetime references, but that won't work in all situations, so instead we'll fix this with ",(0,r.kt)("inlineCode",{parentName:"p"},"Rc<T>"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="src/main.rs"',title:'"src/main.rs"'},'enum List {\n    Cons(i32, Rc<List>),\n    Nil,\n}\n\nuse crate::List::{Cons, Nil};\nuse std::rc::Rc;\n\nfn main() {\n    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));\n    let b = Cons(3, Rc::clone(&a));\n    let c = Cons(4, Rc::clone(&a));\n\n    println!("count after creating c = {}", Rc::strong_count(&a));\n}\n')),(0,r.kt)("p",null,"Now instead of ",(0,r.kt)("inlineCode",{parentName:"p"},"b")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"c")," taking ownership of ",(0,r.kt)("inlineCode",{parentName:"p"},"a"),", then make a clone of ",(0,r.kt)("inlineCode",{parentName:"p"},"a")," which increments ",(0,r.kt)("inlineCode",{parentName:"p"},"Rc<T>"),"'s internal reference count by one. We could have called ",(0,r.kt)("inlineCode",{parentName:"p"},"a.clone()")," instead of ",(0,r.kt)("inlineCode",{parentName:"p"},"Rc::clone(&a)")," here - these do the same thing. The reason we don't is more for reasons of convention. For most types, ",(0,r.kt)("inlineCode",{parentName:"p"},"a.clone()")," would perform a deep copy of the value and all of it's data, so ",(0,r.kt)("inlineCode",{parentName:"p"},"a.clone()")," stands out to the experienced Rust programmer as a potential performance problem. Here we use ",(0,r.kt)("inlineCode",{parentName:"p"},"Rc::clone(&a)")," instead to signal to the reader \"No, this is OK, we're just cloning an ",(0,r.kt)("inlineCode",{parentName:"p"},"Rc<T>"),"."),(0,r.kt)("p",null,"We've also shown here that we can get the reference count out of an ",(0,r.kt)("inlineCode",{parentName:"p"},"Rc<T>"),". Try experimenting with the above code and see what the count is at various points during execution. If you create a scope around ",(0,r.kt)("inlineCode",{parentName:"p"},"c"),", you can see the reference count decrement when ",(0,r.kt)("inlineCode",{parentName:"p"},"c")," is dropped."),(0,r.kt)("p",null,"You may have noticed that we're calling ",(0,r.kt)("inlineCode",{parentName:"p"},"Rc::strong_count")," to get the reference count. If you know what a weak reference is, you'll be unsurprised to learn there's also an ",(0,r.kt)("inlineCode",{parentName:"p"},"Rc::weak_count"),", which we'll hear about more a little later in this chapter. (TODO: link)"),(0,r.kt)("p",null,"Since there are multiple references to the data held by ",(0,r.kt)("inlineCode",{parentName:"p"},"Rc<T>"),", then by Rust ownership rules, this data is going to be read only - we can't get a mutable reference to it."),(0,r.kt)("h2",{id:"155---refcellt-and-the-interior-mutability-pattern"},"15.5 - ",(0,r.kt)("inlineCode",{parentName:"h2"},"RefCell<T>")," and the Interior Mutability Pattern"),(0,r.kt)("p",null,"Suppose for a moment that you're a Rust developer working on a bug in the Rust standard library. You want to keep track of how many times ",(0,r.kt)("inlineCode",{parentName:"p"},"to_lowercase")," is called on a particular string. No problem, you can add a private member to the ",(0,r.kt)("inlineCode",{parentName:"p"},"String")," struct called ",(0,r.kt)("inlineCode",{parentName:"p"},"to_lowercase_called")," and increment it every time someone calls ",(0,r.kt)("inlineCode",{parentName:"p"},"to_lowercase"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"pub fn to_lowercase(&self) -> String {\n    self.to_lowercase_called += 1;\n    // --snip--\n")),(0,r.kt)("p",null,"Oh... wait... ",(0,r.kt)("inlineCode",{parentName:"p"},"to_lowercase")," borrows an immutable reference to ",(0,r.kt)("inlineCode",{parentName:"p"},"self"),", so we can't mutate self. And obviously we can't change the signature of ",(0,r.kt)("inlineCode",{parentName:"p"},"to_lowercase")," without breaking a lot of code."),(0,r.kt)("p",null,"The borrow checker stops us here, because what we're doing isn't ",(0,r.kt)("em",{parentName:"p"},"safe")," - we're mutating an immutable data structure and this could cause a bug elsewhere in the code. But... you an I are smarter than the compiler here. You and I know that incrementing this counter and then reading it out somewhere else isn't going to hurt anything. From any code outside the standard library, this ",(0,r.kt)("inlineCode",{parentName:"p"},"String")," will still look like an immutable ",(0,r.kt)("inlineCode",{parentName:"p"},"String"),"."),(0,r.kt)("p",null,"Rust has a way of doing such things which is called writing ",(0,r.kt)("em",{parentName:"p"},"unsafe")," code, for cases where we're smarter than the compiler, and we know we can do something correctly. (Of course sometimes we only ",(0,r.kt)("em",{parentName:"p"},"think")," we're smarter than the compiler, and what we're doing is something that is both unsafe and incorrect, which will usually end in a panic at runtime, but in this case, totally correct.)"),(0,r.kt)("p",null,"It's important to note that \"unsafe\" doesn't necessarily mean incorrect. There are plenty of C programs in the world performing useful tasks that are correct (or reasonably correct) and C doesn't even have a borrow checker, so all C code is unsafe as far as a Rust programmer is concerned."),(0,r.kt)("p",null,"In this section we're not going to write any unsafe code ourselves, but we're going to make use of ",(0,r.kt)("inlineCode",{parentName:"p"},"RefCell<T>")," which is implemented with unsafe code. ",(0,r.kt)("inlineCode",{parentName:"p"},"RefCell<T>")," is used in a patter called ",(0,r.kt)("em",{parentName:"p"},"interior mutability")," which is essentially exactly what we just described with our ",(0,r.kt)("inlineCode",{parentName:"p"},"to_lowercase")," example. We have some object that we want to look like an immutable object from the outside world, but we want to have some part of it that's mutable for our own purposes on the interior."),(0,r.kt)("h3",{id:"a-use-case-for-interior-mutability-mock-objects"},"A Use Case for Interior Mutability: Mock Objects"),(0,r.kt)("p",null,"Let's look at a concrete example. We're writing code for an email server. Users have quotas, and when they get close to that quota, we want to send them a message. The message gets sent via the ",(0,r.kt)("inlineCode",{parentName:"p"},"Messenger")," trait:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"pub trait Messenger {\n    fn send(&self, msg: &str);\n}\n")),(0,r.kt)("p",null,"How it actually gets sent we don't care. An implementation might send an SMS, or maybe it will - in a fit of irony - send an email and fill up their inbox even more. Here's the code that actually checks the quota:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"pub struct LimitTracker<'a, T: Messenger> {\n    messenger: &'a T,\n    value: usize,\n    max: usize,\n}\n\nimpl<'a, T> LimitTracker<'a, T>\nwhere\n    T: Messenger,\n{\n    pub fn new(messenger: &'a T, max: usize) -> LimitTracker<'a, T> {\n        LimitTracker {\n            messenger,\n            value: 0,\n            max,\n        }\n    }\n\n    pub fn set_value(&mut self, value: usize) {\n        self.value = value;\n\n        let percentage_of_max = self.value as f64 / self.max as f64;\n\n        if percentage_of_max >= 1.0 {\n            self.messenger.send(\"Error: You are over your quota!\");\n        } else if percentage_of_max >= 0.9 {\n            self.messenger\n                .send(\"Urgent warning: You've used up over 90% of your quota!\");\n        } else if percentage_of_max >= 0.75 {\n            self.messenger\n                .send(\"Warning: You've used up over 75% of your quota!\");\n        }\n    }\n}\n")),(0,r.kt)("p",null,"We want to write a test case for ",(0,r.kt)("inlineCode",{parentName:"p"},"set_value"),". To do this we'll create a ",(0,r.kt)("inlineCode",{parentName:"p"},"MockMessenger")," that doesn't actually send a message, but just records all the messages it would have sent. We can create a private ",(0,r.kt)("inlineCode",{parentName:"p"},"Vec<String>")," to store all these messages for testing purposes. But just like our ",(0,r.kt)("inlineCode",{parentName:"p"},"to_lowercase")," example above we have a problem: in order to implement the ",(0,r.kt)("inlineCode",{parentName:"p"},"Messenger")," trait, the ",(0,r.kt)("inlineCode",{parentName:"p"},"send")," method on our ",(0,r.kt)("inlineCode",{parentName:"p"},"MockMessenger")," must borrow ",(0,r.kt)("inlineCode",{parentName:"p"},"self")," immutably. We'll use ",(0,r.kt)("inlineCode",{parentName:"p"},"RefCell<T>")," to implement the interior mutability pattern here:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::cell::RefCell;\n\n    struct MockMessenger {\n        sent_messages: RefCell<Vec<String>>,\n    }\n\n    impl MockMessenger {\n        fn new() -> MockMessenger {\n            MockMessenger {\n                sent_messages: RefCell::new(vec![]),\n            }\n        }\n    }\n\n    impl Messenger for MockMessenger {\n        fn send(&self, message: &str) {\n            self.sent_messages.borrow_mut().push(String::from(message));\n        }\n    }\n\n    #[test]\n    fn it_sends_an_over_75_percent_warning_message() {\n        // --snip--\n\n        assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);\n    }\n}\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"RefCell<T>")," is essentially a new kind of smart pointer. It stores some value on the heap, but it lets us call ",(0,r.kt)("inlineCode",{parentName:"p"},"borrow")," to get an immutable reference to that something and ",(0,r.kt)("inlineCode",{parentName:"p"},"borrow_mut")," to get a mutable reference, even though the ",(0,r.kt)("inlineCode",{parentName:"p"},"RefCell<T>")," itself is immutable. You can think of ",(0,r.kt)("inlineCode",{parentName:"p"},"RefCell<T>")," as two ",(0,r.kt)("inlineCode",{parentName:"p"},"Rc<T>")," in one - it has a reference count for immutable references, and a second reference count for mutable references (which is always either 0 or 1)."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"RefCell<T>")," enforces the exact same safety rules as the borrow checker does. You can only have a single mutable reference at a time, and if you have one you can't also have any immutable references. The key difference is that normally these checks happen at compile time, but with ",(0,r.kt)("inlineCode",{parentName:"p"},"RefCell<T>")," they happen at runtime. If we get things wrong, instead of a compiler error before we ship, our users get a ",(0,r.kt)("inlineCode",{parentName:"p"},"panic"),"."),(0,r.kt)("p",null,"Inside ",(0,r.kt)("inlineCode",{parentName:"p"},"RefCell<T>")," this is all managed with unsafe code, but it bundles it up behind an easy-to-understand API we can use. We say the ",(0,r.kt)("inlineCode",{parentName:"p"},"RefCell<T>")," provides a safe API around unsafe code."),(0,r.kt)("p",null,"One final note about ",(0,r.kt)("inlineCode",{parentName:"p"},"RefCell<T>")," is that, like ",(0,r.kt)("inlineCode",{parentName:"p"},"Rc<T>"),", it is not thread safe."),(0,r.kt)("h3",{id:"having-multiple-owners-of-mutable-data-by-combining-rct-and-refcellt"},"Having Multiple Owners of Mutable Data by Combining ",(0,r.kt)("inlineCode",{parentName:"h3"},"Rc<T>")," and ",(0,r.kt)("inlineCode",{parentName:"h3"},"RefCell<T>")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Rc<T>")," lets us have multiple owners, ",(0,r.kt)("inlineCode",{parentName:"p"},"RefCell<T>")," lets us mutate internal state. We can combine these power together to make something mutable with multiple owners. Looking back to our cons list example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="src/main.rs"',title:'"src/main.rs"'},'#[derive(Debug)]\nenum List {\n    Cons(Rc<RefCell<i32>>, Rc<List>),\n    Nil,\n}\n\nuse crate::List::{Cons, Nil};\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\nfn main() {\n    let value = Rc::new(RefCell::new(5));\n\n    let a = Rc::new(Cons(Rc::clone(&value), Rc::new(Nil)));\n\n    let b = Cons(Rc::new(RefCell::new(3)), Rc::clone(&a));\n    let c = Cons(Rc::new(RefCell::new(4)), Rc::clone(&a));\n\n    *value.borrow_mut() += 10;\n\n    println!("a after = {:?}", a);\n    println!("b after = {:?}", b);\n    println!("c after = {:?}", c);\n}\n')),(0,r.kt)("h2",{id:"156---reference-cycles-can-leak-memory"},"15.6 - Reference Cycles Can Leak Memory"),(0,r.kt)("p",null,"In C it's easy to create a memory leak; just ",(0,r.kt)("inlineCode",{parentName:"p"},"malloc")," some memory and never free it. In a language like Rust it's not so simple, but it can definitely be done. One way to do it is with ",(0,r.kt)("inlineCode",{parentName:"p"},"Rc<T>"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"RefCell<T>"),", and a circular reference. The problem is that ",(0,r.kt)("inlineCode",{parentName:"p"},"Rc<T>")," uses a simple reference count to know when memory is safe to free, but if we have two ",(0,r.kt)("inlineCode",{parentName:"p"},"Rc<T>"),"s that point to each other (which isn't an easy thing to do), then even with no one else referencing them, they'll both have a reference count of 1."),(0,r.kt)("p",null,"In a garbage collected language like Java or JavaScript, this problem is solved using ",(0,r.kt)("em",{parentName:"p"},"reachability"),". The two values are reachable from each other, but neither is reachable from the ",(0,r.kt)("em",{parentName:"p"},"root set"),". We have no garbage collector in Rust, and ",(0,r.kt)("inlineCode",{parentName:"p"},"Rc<T>")," is simply not smart enough to get out of this situation in its own, so we leak memory."),(0,r.kt)("h3",{id:"creating-a-reference-cycle"},"Creating a Reference Cycle"),(0,r.kt)("p",null,"Let's look at a slightly modified version of our cons list example, where the pointer to the next item in the list is mutable via ",(0,r.kt)("inlineCode",{parentName:"p"},"RefCell<T>"),". We then set up two lists elements which each have a next pointing to each other:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="src/main.rs"',title:'"src/main.rs"'},'#[derive(Debug)]\nenum List {\n    Cons(i32, RefCell<Rc<List>>),\n    Nil,\n}\n\nuse crate::List::{Cons, Nil};\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\nimpl List {\n    fn tail(&self) -> Option<&RefCell<Rc<List>>> {\n        match self {\n            Cons(_, item) => Some(item),\n            Nil => None,\n        }\n    }\n}\n\nfn main() {\n    // Create `a` which is essentially `[5]`.\n    let a = Rc::new(Cons(5, RefCell::new(Rc::new(Nil))));\n    // Create `b` which is essentially `[10, 5]`\n    let b = Rc::new(Cons(10, RefCell::new(Rc::clone(&a))));\n\n    // Set a\'s `next` to be `b`.  `a` is now the list `[5, 10, 5, 10, 5, 10...]`.\n    if let Some(link) = a.tail() {\n        *link.borrow_mut() = Rc::clone(&b);\n    }\n\n    // These will both be 2, because `a` and `b` are refs to these values,\n    // (which is the first count) and they also point to each other\n    // (which is the second).\n    println!("b rc count after changing a = {}", Rc::strong_count(&b));\n    println!("a rc count after changing a = {}", Rc::strong_count(&a));\n\n    // Uncomment the next line to see that we have a cycle;\n    // it will overflow the stack\n    // println!("a next item = {:?}", a.tail());\n}\n')),(0,r.kt)("p",null,"Have a quick read through that example and you'll see that both ",(0,r.kt)("inlineCode",{parentName:"p"},"a")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"b")," end pointing to each other. Both ",(0,r.kt)("inlineCode",{parentName:"p"},"a")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"b")," end up with a ",(0,r.kt)("inlineCode",{parentName:"p"},"strong_count")," of 2. When we hit the end of the ",(0,r.kt)("inlineCode",{parentName:"p"},"main")," function, ",(0,r.kt)("inlineCode",{parentName:"p"},"a")," will be dropped, reducing the ref count for a's ",(0,r.kt)("inlineCode",{parentName:"p"},"Rc<List>")," to 1 (the one from ",(0,r.kt)("inlineCode",{parentName:"p"},"b"),"), and the same will happen to ",(0,r.kt)("inlineCode",{parentName:"p"},"b"),". As a result, even though there are no more ",(0,r.kt)("inlineCode",{parentName:"p"},"Rc")," objects left using this memory, the memory will never be freed."),(0,r.kt)("h3",{id:"preventing-reference-cycles-turning-an-rct-into-a-weakt"},"Preventing Reference Cycles: Turning an ",(0,r.kt)("inlineCode",{parentName:"h3"},"Rc<T>")," into a ",(0,r.kt)("inlineCode",{parentName:"h3"},"Weak<T>")),(0,r.kt)("p",null,"One way to solve the problem we presented in the previous section is to make it so some objects have ownership over the values pointed to with a smart point, and some do not. It doesn't lend itself well to the example we just used, so we're going to use a new example here, using a tree data structure. We're going to have ",(0,r.kt)("inlineCode",{parentName:"p"},"Node"),"s that have a mutable list of references to their children, and each child will have a reference to the parent. This structure is full of circular references: a parent node points to each child, and each child points back to the parent."),(0,r.kt)("p",null,"To prevent a possible memory leak, here we'll make the parent references ",(0,r.kt)("em",{parentName:"p"},"strong")," and the child references ",(0,r.kt)("em",{parentName:"p"},"weak"),". In other words, if a child has a reference to a parent, that reference won't count towards the reference count that ",(0,r.kt)("inlineCode",{parentName:"p"},"Rc<T>")," uses:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="src/main.rs"',title:'"src/main.rs"'},'use std::cell::RefCell;\nuse std::rc::{Rc, Weak};\n\n#[derive(Debug)]\nstruct Node {\n    value: i32,\n    parent: RefCell<Weak<Node>>,\n    children: RefCell<Vec<Rc<Node>>>,\n}\n\nfn main() {\n    // Create a leaf node\n    let leaf = Rc::new(Node {\n        value: 3,\n        parent: RefCell::new(Weak::new()),\n        children: RefCell::new(vec![]),\n    });\n\n    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());\n\n    // Create a parent for the leaf node\n    let branch = Rc::new(Node {\n        value: 5,\n        parent: RefCell::new(Weak::new()),\n        children: RefCell::new(vec![Rc::clone(&leaf)]),\n    });\n\n    // Wire up `leaf`\'s parent to point `branch`\n    *leaf.parent.borrow_mut() = Rc::downgrade(&branch);\n\n    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());\n}\n')),(0,r.kt)("p",null,"We already know that calling ",(0,r.kt)("inlineCode",{parentName:"p"},"rc::clone")," will increment the ",(0,r.kt)("inlineCode",{parentName:"p"},"strong_count")," for that ",(0,r.kt)("inlineCode",{parentName:"p"},"Rc")," and return back a new ",(0,r.kt)("inlineCode",{parentName:"p"},"Rc")," that points to the same memory. Here ",(0,r.kt)("inlineCode",{parentName:"p"},"Rc::downgrade")," works the same way, except instead of returning an ",(0,r.kt)("inlineCode",{parentName:"p"},"Rc<Node>")," it returns a ",(0,r.kt)("inlineCode",{parentName:"p"},"Weak<Node>")," and instead of incrementing ",(0,r.kt)("inlineCode",{parentName:"p"},"strong_count")," it increments ",(0,r.kt)("inlineCode",{parentName:"p"},"weak_count"),". When an ",(0,r.kt)("inlineCode",{parentName:"p"},"Rc")," is dropped, if the ",(0,r.kt)("inlineCode",{parentName:"p"},"strong_count")," is decremented to 0 the underlying memory will be freed, even if the ",(0,r.kt)("inlineCode",{parentName:"p"},"weak_count")," is still positive."),(0,r.kt)("p",null,"This means that whenever we want to deference a ",(0,r.kt)("inlineCode",{parentName:"p"},"Weak<Node>"),", we just have to check that there's still something in there. We do this by calling ",(0,r.kt)("inlineCode",{parentName:"p"},"Weak::upgrade")," on the ",(0,r.kt)("inlineCode",{parentName:"p"},"Weak<Node>"),", which will return an ",(0,r.kt)("inlineCode",{parentName:"p"},"Option<Rc<Node>>"),". If the underlying memory hasn't been cleaned up yet, then ",(0,r.kt)("inlineCode",{parentName:"p"},"Weak::upgrade")," returns a new ",(0,r.kt)("inlineCode",{parentName:"p"},"Rc<Node>")," instance (which increments the strong_count, as you might expect) and if not, it returns a ",(0,r.kt)("inlineCode",{parentName:"p"},"None")," to let you know your weak reference isn't valid anymore."),(0,r.kt)("p",null,"Since the relationship from child-to-parent is weak, if we drop a parent, it's ",(0,r.kt)("inlineCode",{parentName:"p"},"strong_count")," will drop to 0, and the entire tree will end up being freed. No more leaks!"),(0,r.kt)("p",null,"Continue to ",(0,r.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch16-fearless-concurrency",title:"Chapter 16: Fearless Concurrency"},"chapter 16"),"."))}d.isMDXComponent=!0}}]);