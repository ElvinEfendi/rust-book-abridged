"use strict";(self.webpackChunkrust_book_abridged=self.webpackChunkrust_book_abridged||[]).push([[7800],{3905:(e,t,n)=>{n.d(t,{Zo:()=>h,kt:()=>f});var i=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},r=Object.keys(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=i.createContext({}),p=function(e){var t=i.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},h=function(e){var t=p(e.components);return i.createElement(l.Provider,{value:t},e.children)},m="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},u=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,l=e.parentName,h=s(e,["components","mdxType","originalType","parentName"]),m=p(n),u=a,f=m["".concat(l,".").concat(u)]||m[u]||c[u]||r;return n?i.createElement(f,o(o({ref:t},h),{},{components:n})):i.createElement(f,o({ref:t},h))}));function f(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,o=new Array(r);o[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[m]="string"==typeof e?e:a,o[1]=s;for(var p=2;p<r;p++)o[p]=n[p];return i.createElement.apply(null,o)}return i.createElement.apply(null,n)}u.displayName="MDXCreateElement"},1834:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>c,frontMatter:()=>r,metadata:()=>s,toc:()=>p});var i=n(7462),a=(n(7294),n(3905));const r={},o="10.3 - Validating References with Lifetimes",s={unversionedId:"ch10/ch10-03-lifetimes",id:"ch10/ch10-03-lifetimes",title:"10.3 - Validating References with Lifetimes",description:"Every reference in Rust has a lifetime where the reference is valid. This has to do with ownership, so it's a feature that's somewhat unique to Rust.",source:"@site/docs/ch10/ch10-03-lifetimes.md",sourceDirName:"ch10",slug:"/ch10/ch10-03-lifetimes",permalink:"/rust-book-abridged/ch10/ch10-03-lifetimes",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/ch10/ch10-03-lifetimes.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"10.2 - Traits: Defining Shared Behavior",permalink:"/rust-book-abridged/ch10/ch10-02-traits"},next:{title:"11 - Writing Automated Tests",permalink:"/rust-book-abridged/ch11-automated-tests"}},l={},p=[{value:"Preventing Dangling References with Lifetimes",id:"preventing-dangling-references-with-lifetimes",level:2},{value:"Generic Lifetimes in Functions",id:"generic-lifetimes-in-functions",level:2},{value:"Lifetime Annotation Syntax",id:"lifetime-annotation-syntax",level:2},{value:"Lifetime Annotations in Function Signatures",id:"lifetime-annotations-in-function-signatures",level:2},{value:"Thinking in Terms of Lifetimes",id:"thinking-in-terms-of-lifetimes",level:2},{value:"Lifetime Annotations in Struct Definitions",id:"lifetime-annotations-in-struct-definitions",level:2},{value:"Lifetime Elision",id:"lifetime-elision",level:2},{value:"Lifetime Annotations in Method Definitions",id:"lifetime-annotations-in-method-definitions",level:2},{value:"The Static Lifetime",id:"the-static-lifetime",level:2},{value:"Generic Type Parameters, Trait Bounds, and Lifetimes Together",id:"generic-type-parameters-trait-bounds-and-lifetimes-together",level:2},{value:"Further Reading",id:"further-reading",level:2}],h={toc:p},m="wrapper";function c(e){let{components:t,...n}=e;return(0,a.kt)(m,(0,i.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"103---validating-references-with-lifetimes"},"10.3 - Validating References with Lifetimes"),(0,a.kt)("p",null,"Every reference in Rust has a ",(0,a.kt)("em",{parentName:"p"},"lifetime")," where the reference is valid. This has to do with ",(0,a.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch04-ownership",title:"Chapter 4: Ownership, References, and Slices"},"ownership"),", so it's a feature that's somewhat unique to Rust."),(0,a.kt)("p",null,"Just as rustc infers the type of many of our parameters, in most cases Rust can infer the lifetime of a reference (usually from when it is created until it's last use in a function). Just as we can explicitly annotate a variable's type, we can also explicitly annotate the lifetime of a reference in cases where the compiler can't infer what we want."),(0,a.kt)("h2",{id:"preventing-dangling-references-with-lifetimes"},"Preventing Dangling References with Lifetimes"),(0,a.kt)("p",null,"The main point of ownership is to prevent dangling references - to prevent us from accessing memory after it has been freed. Here's an example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"fn main() {\n    let r;                // ---------+-- 'a\n                          //          |\n    {                     //          |\n        let x = 5;        // -+-- 'b  |\n        r = &x;           //  |       |\n    }                     // -+       |\n                          //          |\n    println!(\"r: {}\", r); //          |\n}                         // ---------+\n")),(0,a.kt)("p",null,"If you try this, it won't compile. The variable ",(0,a.kt)("inlineCode",{parentName:"p"},"r")," is in scope for the entire ",(0,a.kt)("inlineCode",{parentName:"p"},"main()")," function, but it's a reference to ",(0,a.kt)("inlineCode",{parentName:"p"},"x")," which will be dropped when we reach the end of the inner scope. After we reach the end of that inner scope, ",(0,a.kt)("inlineCode",{parentName:"p"},"r")," is now a reference to freed memory, so Rust's ",(0,a.kt)("em",{parentName:"p"},"borrow checker")," won't let us use it."),(0,a.kt)("p",null,"More formally, we can say that ",(0,a.kt)("inlineCode",{parentName:"p"},"r")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"x")," have different lifetimes, which we've marked in the comments of this example, using the labels ",(0,a.kt)("inlineCode",{parentName:"p"},"'a")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"'b")," (strange names, but this is actually a bit of foreshadowing). The borrow checker sees that ",(0,a.kt)("inlineCode",{parentName:"p"},"r")," has a lifetime of ",(0,a.kt)("inlineCode",{parentName:"p"},"'a"),", but references memory that has the lifetime ",(0,a.kt)("inlineCode",{parentName:"p"},"'b"),", and since ",(0,a.kt)("inlineCode",{parentName:"p"},"'b")," is shorter than ",(0,a.kt)("inlineCode",{parentName:"p"},"'a"),", the borrow checker won't allow this."),(0,a.kt)("p",null,"This version fixes the bug:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"fn main() {\n    let x = 5;            // ----------+-- 'b\n                          //           |\n    let r = &x;           // --+-- 'a  |\n                          //   |       |\n    println!(\"r: {}\", r); //   |       |\n                          // --+       |\n}                         // ----------+\n")),(0,a.kt)("p",null,"Here ",(0,a.kt)("inlineCode",{parentName:"p"},"x")," has a larger lifetime than ",(0,a.kt)("inlineCode",{parentName:"p"},"r"),", so ",(0,a.kt)("inlineCode",{parentName:"p"},"r")," can be a valid reference to ",(0,a.kt)("inlineCode",{parentName:"p"},"x"),"."),(0,a.kt)("h2",{id:"generic-lifetimes-in-functions"},"Generic Lifetimes in Functions"),(0,a.kt)("p",null,"Now for an example that doesn't compile, for what might not at first be obvious reasons. We're going to pass two string slices to a ",(0,a.kt)("inlineCode",{parentName:"p"},"longest()")," function, and it will return back whichever is longer:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n    let string1 = String::from("abcd");\n    let string2 = "xyz";\n\n    let result = longest(string1.as_str(), string2);\n    println!("The longest string is {}", result);\n}\n\n// This doesn\'t work!\nfn longest(x: &str, y: &str) -> &str {\n    if x.len() > y.len() {\n        x\n    } else {\n        y\n    }\n}\n')),(0,a.kt)("p",null,"If we try to compile this, we get an error from the borrow checker. The root of the problem here is that in this function, the rust compiler doesn't know ahead of time whether we're going to return ",(0,a.kt)("inlineCode",{parentName:"p"},"x")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"y"),", and since these may have different lifetimes, the compiler can't know how long the returned reference will be valid for. Consider this example of calling this function:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n    let string1 = String::from("abcd");\n    let result;\n\n    {\n        let string2 = String::from("xyz");\n        result = longest(&string1, &string2);\n    }\n\n    // This shouldn\'t compile! But how does rust know that?\n    println!("The longest string is {}", result);\n}\n')),(0,a.kt)("p",null,"Here if ",(0,a.kt)("inlineCode",{parentName:"p"},"longest()")," returned the reference to ",(0,a.kt)("inlineCode",{parentName:"p"},"string1"),", it would still be valid by the time we get to the ",(0,a.kt)("inlineCode",{parentName:"p"},"println!"),", but if it returned the reference to ",(0,a.kt)("inlineCode",{parentName:"p"},"string2")," it would not. How is the borrow checker supposed to decide if the call to ",(0,a.kt)("inlineCode",{parentName:"p"},"longest()")," is valid? The answer is that it can't. At least, not without a little help from us."),(0,a.kt)("h2",{id:"lifetime-annotation-syntax"},"Lifetime Annotation Syntax"),(0,a.kt)("p",null,"We fix this problem by telling the compiler about the relationship between these references. We do this with ",(0,a.kt)("em",{parentName:"p"},"lifetime annotations"),". Lifetime references are of the form ",(0,a.kt)("inlineCode",{parentName:"p"},"'a"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"&i32        // a reference\n&'a i32     // a reference with an explicit lifetime\n&'a mut i32 // a mutable reference with an explicit lifetime\n")),(0,a.kt)("p",null,"A lifetime annotation on a single variable isn't very meaningful. Lifetime annotations really describe a constraint on the relationship of references between multiple variables."),(0,a.kt)("h2",{id:"lifetime-annotations-in-function-signatures"},"Lifetime Annotations in Function Signatures"),(0,a.kt)("p",null,"We can declare a lifetime annotation for a function in much the same way we add generic types. The lifetime annotation must start with a ",(0,a.kt)("inlineCode",{parentName:"p"},"'"),". Typically they are single characters, much like generic types."),(0,a.kt)("p",null,"We can fix the ",(0,a.kt)("inlineCode",{parentName:"p"},"longest()")," function in our previous example with:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {\n    if x.len() > y.len() {\n        x\n    } else {\n        y\n    }\n}\n")),(0,a.kt)("p",null,"What we've done here is to tell the compiler that this function takes an ",(0,a.kt)("inlineCode",{parentName:"p"},"x")," and a ",(0,a.kt)("inlineCode",{parentName:"p"},"y"),", both of which will live for some lifetime which we've called ",(0,a.kt)("inlineCode",{parentName:"p"},"'a"),". This doesn't mean the two parameters passed in need to have the exact same lifetime, it only means that ",(0,a.kt)("inlineCode",{parentName:"p"},"'a")," is the lifetime of the shorter of the two. We say we're going to return a reference that has that same lifetime. In other words we're telling the compiler that the return value of ",(0,a.kt)("inlineCode",{parentName:"p"},"longest()")," will live at least as long as the shorter lifetime of ",(0,a.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"y"),". When the rust compiler analyzes a call to ",(0,a.kt)("inlineCode",{parentName:"p"},"longest()")," it can now mark it as an error if the two parameters passed in don't adhere to this constraint."),(0,a.kt)("p",null,"It's important to note that these annotations don't actually change the lifetime of the references passed in, it only gives the borrow checker enough information to work out whether a call is valid."),(0,a.kt)("p",null,"Returning to this example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n    let string1 = String::from("abcd");\n    let result;\n\n    {\n        let string2 = String::from("xyz");\n        result = longest(&string1, &string2);\n    }\n\n    // This doesn\'t compile!\n    println!("The longest string is {}", result);\n}\n')),(0,a.kt)("p",null,"Here the compiler now knows that the return value of ",(0,a.kt)("inlineCode",{parentName:"p"},"longest()")," is only as long as the shorter of ",(0,a.kt)("inlineCode",{parentName:"p"},"&string1")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"&string2"),", so it knows that the use of ",(0,a.kt)("inlineCode",{parentName:"p"},"result")," in the ",(0,a.kt)("inlineCode",{parentName:"p"},"println!")," macro is invalid."),(0,a.kt)("h2",{id:"thinking-in-terms-of-lifetimes"},"Thinking in Terms of Lifetimes"),(0,a.kt)("p",null,"The way we annotate lifetimes depends on what the function is doing. If we changed ",(0,a.kt)("inlineCode",{parentName:"p"},"longest()")," to only ever return the first parameter, we could annotate the lifetimes as:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"fn longest<'a>(x: &'a str, y: &str) -> &'a str {\n    x\n}\n")),(0,a.kt)("p",null,"This tells rustc that the lifetime of the return value is the same as the lifetime of the first parameter."),(0,a.kt)("p",null,"The lifetime of the return value must have the same annotation as at least one of the parameters. If you created a reference to something you create inside the function and return it, whatever you created will be dropped at the end of the function, so the reference will be invalid."),(0,a.kt)("h2",{id:"lifetime-annotations-in-struct-definitions"},"Lifetime Annotations in Struct Definitions"),(0,a.kt)("p",null,"So far all the structs we've created in this book have owned all their types. If we want to store a reference in a struct, we can, but we need to annotate it's type. Just like a function, we do this with the generic syntax:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"struct ImportantExcerpt<'a> {\n    part: &'a str,\n}\n\nfn main() {\n    let novel = String::from(\"Call me Ishmael. Some years ago...\");\n    let first_sentence = novel.split('.').next().expect(\"Could not find a '.'\");\n    let i = ImportantExcerpt {\n        part: first_sentence,\n    };\n}\n")),(0,a.kt)("p",null,"This is subtly different from the lifetime annotations in a function. When we write ",(0,a.kt)("inlineCode",{parentName:"p"},"ImportantExcerpt<'a>")," we are saying \"there exists some lifetime which we'll call ",(0,a.kt)("inlineCode",{parentName:"p"},"'a"),'" (just like when we write ',(0,a.kt)("inlineCode",{parentName:"p"},"Option<T>")," we're saying \"there exists some type which we'll call ",(0,a.kt)("inlineCode",{parentName:"p"},"T"),"). When we write ",(0,a.kt)("inlineCode",{parentName:"p"},"part: &'a str"),", we're saying that the ",(0,a.kt)("inlineCode",{parentName:"p"},"part")," has a lifetime of ",(0,a.kt)("inlineCode",{parentName:"p"},"'a"),". After this the compiler will ensure that the ",(0,a.kt)("inlineCode",{parentName:"p"},"ImportantExcerpt")," will have a lifetime of ",(0,a.kt)("inlineCode",{parentName:"p"},"'a")," or less, or in other words any ",(0,a.kt)("inlineCode",{parentName:"p"},"ImportantExcerpt")," can't outlive the lifetime of the ",(0,a.kt)("inlineCode",{parentName:"p"},"part")," stored inside it."),(0,a.kt)("p",null,'You might think "Well of course an ',(0,a.kt)("inlineCode",{parentName:"p"},"ImportantExcerpt")," can't live longer than any ref stored inside it. A ref always has to be valid so a struct obviously can't outlive any ref inside the struct.\" Sadly, Rust requires us to annotate this lifetime explicitly. (There are many cases where Rust figures out lifetimes for us as we'll see in a minute.)"),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"},"If you're wondering under what circumstances you'd have a struct with more than one lifetime reference, ",(0,a.kt)("a",{parentName:"p",href:"https://stackoverflow.com/questions/29861388/when-is-it-useful-to-define-multiple-lifetimes-in-a-struct#29862184"},"this discussion on Stack Overflow")," has some examples and interesting discussion.")),(0,a.kt)("h2",{id:"lifetime-elision"},"Lifetime Elision"),(0,a.kt)("p",null,"Way back in ",(0,a.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch04-ownership",title:"Chapter 4: Ownership, References, and Slices"},"chapter 4"),", we wrote this function:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"fn first_word(s: &str) -> &str {\n    let bytes = s.as_bytes();\n\n    for (i, &item) in bytes.iter().enumerate() {\n        if item == b' ' {\n            return &s[0..i];\n        }\n    }\n\n    &s[..]\n}\n")),(0,a.kt)("p",null,"How come this compiles without lifetime annotations? Why don't we have to tell the compiler that the return value has the same lifetime as ",(0,a.kt)("inlineCode",{parentName:"p"},"s"),"? Actually, in the pre-1.0 days of Rust, lifetime annotations would have been mandatory here. But there are certain cases where Rust can now work out the lifetime on it's own. We call this ",(0,a.kt)("em",{parentName:"p"},"lifetime elision"),", and say that the compiler ",(0,a.kt)("em",{parentName:"p"},"elides")," these lifetime annotations for us."),(0,a.kt)("p",null,"What the compiler does is to assign a different lifecycle to every reference in the parameter list (",(0,a.kt)("inlineCode",{parentName:"p"},"'a")," for the first one, ",(0,a.kt)("inlineCode",{parentName:"p"},"'b")," for the second, and so on...). If there is exactly one input lifetime parameter, that lifecycle is automatically assigned to all output parameters. If there is more than one input lifetime parameter but one of them is for ",(0,a.kt)("inlineCode",{parentName:"p"},"&self"),", then the lifetime of ",(0,a.kt)("inlineCode",{parentName:"p"},"self")," is assigned to all output parameters. Otherwise, the compiler will error."),(0,a.kt)("p",null,"In the case above, there's only one lifetime that ",(0,a.kt)("inlineCode",{parentName:"p"},"first_word")," could really be returning; if ",(0,a.kt)("inlineCode",{parentName:"p"},"first_word")," created a new ",(0,a.kt)("inlineCode",{parentName:"p"},"String")," and tried to return a reference to it, the new ",(0,a.kt)("inlineCode",{parentName:"p"},"String")," would be dropped when we leave the function and the reference would be invalid. The only sensible reference for it to return comes from ",(0,a.kt)("inlineCode",{parentName:"p"},"s"),", so Rust infers this for us. (It ",(0,a.kt)("em",{parentName:"p"},"could")," be a static lifetime, but if it were we'd have to explicitly annotate it as such.)"),(0,a.kt)("h2",{id:"lifetime-annotations-in-method-definitions"},"Lifetime Annotations in Method Definitions"),(0,a.kt)("p",null,"We can add lifetime annotations to methods using the exact same generic syntax we use for generic structs:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"impl<'a> ImportantExcerpt<'a> {\n    fn level(&self) -> i32 {\n        3\n    }\n\n    fn announce_and_return_part(&self, announcement: &str) -> &str {\n        println!(\"Attention please: {}\", announcement);\n        self.part\n    }\n}\n")),(0,a.kt)("p",null,"Here ",(0,a.kt)("inlineCode",{parentName:"p"},"'a")," refers to the lifetime of the struct itself, but thanks to lifetime elision, in ",(0,a.kt)("inlineCode",{parentName:"p"},"announce_and_return_part()"),", the return value is automatically given the same lifetime as ",(0,a.kt)("inlineCode",{parentName:"p"},"self,")," so we don't actually have to use it."),(0,a.kt)("h2",{id:"the-static-lifetime"},"The Static Lifetime"),(0,a.kt)("p",null,"There's a special lifetime called the ",(0,a.kt)("inlineCode",{parentName:"p"},"'static")," lifetime:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'let s: &\'static str = "I have a static lifetime.";\n')),(0,a.kt)("p",null,"This is a slice of a string that's part of the program's binary, so it will always be available. you may see the ",(0,a.kt)("inlineCode",{parentName:"p"},"'static")," lifetime mentioned in error messages when Rust suggests a fix, but unless you actually want a reference that lasts the life of your program, likely the real problem is that you're trying to create a dangling reference or there's lifetime mismatch."),(0,a.kt)("h2",{id:"generic-type-parameters-trait-bounds-and-lifetimes-together"},"Generic Type Parameters, Trait Bounds, and Lifetimes Together"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"use std::fmt::Display;\n\nfn longest_with_an_announcement<'a, T>(\n    x: &'a str,\n    y: &'a str,\n    announcement: T,\n) -> &'a str\nwhere\n    T: Display,\n{\n    println!(\"Announcement! {}\", announcement);\n    if x.len() > y.len() {\n        x\n    } else {\n        y\n    }\n}\n")),(0,a.kt)("p",null,"This takes two string slices and returns whichever is longer. It also prints an announcement, which is passed in as a parameter and can be any type that implements the ",(0,a.kt)("inlineCode",{parentName:"p"},"Display")," trait. (If someone showed you this code before you started reading this book, I wonder what would you have thought it meant?)"),(0,a.kt)("h2",{id:"further-reading"},"Further Reading"),(0,a.kt)("p",null,"There are some advanced cases where lifetime annotations are required that we haven't discussed here (for example trait bounds sometimes require ",(0,a.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/stable/reference/types/trait-object.html#trait-object-lifetime-bounds"},"lifetime annotations"),", but they are usually inferred). ",(0,a.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/reference/index.html"},"The Rust Reference")," is a good place to read about this sort of thing when you're a little more comfortable with the language."),(0,a.kt)("p",null,"Lifetimes and ownership are such a central and important part of Rust that I'll also direct you to ",(0,a.kt)("a",{parentName:"p",href:"https://mobiarch.wordpress.com/2015/06/29/understanding-lifetime-in-rust-part-i/"},"this excellent two part blog post")," on the subject."),(0,a.kt)("p",null,"Continue to ",(0,a.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch11-automated-tests",title:"Chapter 11: Writing Automated Tests"},"chapter 11"),"."))}c.isMDXComponent=!0}}]);