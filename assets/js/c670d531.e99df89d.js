"use strict";(self.webpackChunkrust_book_abridged=self.webpackChunkrust_book_abridged||[]).push([[3528],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>d});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},u="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=p(n),m=r,d=u["".concat(l,".").concat(m)]||u[m]||h[m]||o;return n?a.createElement(d,i(i({ref:t},c),{},{components:n})):a.createElement(d,i({ref:t},c))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[u]="string"==typeof e?e:r,i[1]=s;for(var p=2;p<o;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},6356:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>p});var a=n(7462),r=(n(7294),n(3905));const o={},i="4 - Ownership, References, and Slices",s={unversionedId:"ch04-ownership",id:"ch04-ownership",title:"4 - Ownership, References, and Slices",description:"4.1 - What is Ownership?",source:"@site/docs/ch04-ownership.md",sourceDirName:".",slug:"/ch04-ownership",permalink:"/rust-book-abridged/ch04-ownership",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/ch04-ownership.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"3 - Common Programming Concepts",permalink:"/rust-book-abridged/ch03-common-programming-concepts"},next:{title:"5 - Using Structs to Structure Related Data",permalink:"/rust-book-abridged/ch05-structs"}},l={},p=[{value:"4.1 - What is Ownership?",id:"41---what-is-ownership",level:2},{value:"Ownership Rules",id:"ownership-rules",level:3},{value:"Memory and Allocation",id:"memory-and-allocation",level:3},{value:"There Can Only Be One",id:"there-can-only-be-one",level:3},{value:"Stack-Only Data: Copy",id:"stack-only-data-copy",level:3},{value:"Ownership and Functions",id:"ownership-and-functions",level:3},{value:"4.2 - References and Borrowing",id:"42---references-and-borrowing",level:2},{value:"Mutable References",id:"mutable-references",level:3},{value:"Dereferencing",id:"dereferencing",level:2},{value:"Dangling References",id:"dangling-references",level:3},{value:"The Rules of References",id:"the-rules-of-references",level:3},{value:"4.3 - The Slice Type",id:"43---the-slice-type",level:2},{value:"String Literals as Slices",id:"string-literals-as-slices",level:3},{value:"String Slices as Parameters",id:"string-slices-as-parameters",level:3},{value:"Other Slices",id:"other-slices",level:3}],c={toc:p},u="wrapper";function h(e){let{components:t,...n}=e;return(0,r.kt)(u,(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"4---ownership-references-and-slices"},"4 - Ownership, References, and Slices"),(0,r.kt)("h2",{id:"41---what-is-ownership"},"4.1 - What is Ownership?"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Ownership is Rust's most unique feature and has deep implications for the rest of the language. It enables Rust to make memory safety guarantees without needing a garbage collector, so it's important to understand how ownership works. In this chapter, we'll talk about ownership as well as several related features: borrowing, slices, and how Rust lays data out in memory.")),(0,r.kt)("p",null,"-- The Rust Programming Language"),(0,r.kt)("p",null,"The idea of ownership is quite core to Rust. If you're coming from a language like Python or JavaScript, and you're not familiar with the idea of the ",(0,r.kt)("a",{parentName:"p",href:"https://www.geeksforgeeks.org/stack-vs-heap-memory-allocation/"},"the stack and heap")," it's worth reading up about them. We're going to assume you're familiar with them in this chapter."),(0,r.kt)("p",null,"In a language like C, we allocate memory on the stack by declaring local variables in a function, and we allocate and free memory on the heap by explicitly calling ",(0,r.kt)("inlineCode",{parentName:"p"},"malloc")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"free"),". All memory management is up to us, which means it's easy to make mistakes."),(0,r.kt)("p",null,"In a language like Java or JavaScript, simple variables like numbers or booleans get allocated on the stack in much the same way, and more complicated object get allocated on the heap. Memory is allocated automatically without us having to think about it, so memory allocation is very safe, but this incurs a runtime cost in the form of garbage collection."),(0,r.kt)("p",null,"Rust does neither of these things. Instead in Rust, every piece of memory is owned by some variable called the ",(0,r.kt)("em",{parentName:"p"},"owner"),". Ownership of a particular piece of memory can be transferred from one variable to another, and in some cases memory can be ",(0,r.kt)("em",{parentName:"p"},"borrowed"),". Once no one owns the memory anymore, it can safely be freed or, as Rust calls it, ",(0,r.kt)("em",{parentName:"p"},"dropped"),"."),(0,r.kt)("h3",{id:"ownership-rules"},"Ownership Rules"),(0,r.kt)("p",null,"From the original Rust Book:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Each value in Rust has an owner."),(0,r.kt)("li",{parentName:"ul"},"There can only be one owner at a time."),(0,r.kt)("li",{parentName:"ul"},"When the owner goes out of scope, the value will be ",(0,r.kt)("em",{parentName:"li"},"dropped"),".")),(0,r.kt)("p",null,"The ",(0,r.kt)("em",{parentName:"p"},"scope"),' of a variable in Rust works much like it does in most other languages - inside a set of curly braces, any variables you declare can be accessed only after their declaration, and they go "out of scope" once we hit the closing brace. The key thing about Rust is that once a variable goes out of scope, if that variable currently owns some memory, then that memory will be freed.'),(0,r.kt)("h3",{id:"memory-and-allocation"},"Memory and Allocation"),(0,r.kt)("p",null,"Here's a trivial example demonstrating some memory being allocated on the heap and then freed:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'fn foo() {\n\n    if (true) {\n        // Create the variable `s` to own a String.\n        // Remember that Strings can store an arbitrary\n        // length of data, so need to allocate memory\n        // on the heap.\n        let s = String::from("hello");\n\n        // Do stuff with s\n\n    }\n    // At this point `s` has fallen out of scope, so the\n    // String that was owned by s, and the memory it\n    // allocated on the heap, will be freed.\n}\n')),(0,r.kt)("p",null,'I say this is a trivial example, because you might read that and scratch your head and think "If everything disappears when it goes out of scope, isn\'t this the same as just allocating everything on the stack?" And this would be true, except that ownership can be ',(0,r.kt)("em",{parentName:"p"},"moved"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n    let s_main = foo();\n    println!("{}", s_main);\n}\n\nfn foo() -> String {\n    let s_foo = String::from("hello world");\n    return s_foo;\n}\n')),(0,r.kt)("p",null,"Here ",(0,r.kt)("inlineCode",{parentName:"p"},"foo")," creates a String, which allocates some memory on the heap, and ",(0,r.kt)("inlineCode",{parentName:"p"},"s_foo")," is the owner of that String. foo() returns ",(0,r.kt)("inlineCode",{parentName:"p"},"s_foo"),", so ownership of the String (and the associated memory on the heap) is moved to ",(0,r.kt)("inlineCode",{parentName:"p"},"s_main")," in the caller. When we reach the end of ",(0,r.kt)("inlineCode",{parentName:"p"},"main"),", then ",(0,r.kt)("inlineCode",{parentName:"p"},"s_main")," falls out-of-scope, and the memory can be freed."),(0,r.kt)("h3",{id:"there-can-only-be-one"},"There Can Only Be One"),(0,r.kt)("p",null,"Remember that we said there can only be one owner at a time?"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'fn strings() {\n    let s1 = String::from("hello");\n    let s2 = s1;\n\n    println!("{}", s1);\n}\n')),(0,r.kt)("p",null,"This code fails to compile with the error:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-txt"},'error[E0382]: borrow of moved value: `s1`\n  --\x3e src/main.rs:23:20\n   |\n 2 |     let s1 = String::from("hello");\n   |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait\n 3 |     let s2 = s1;\n   |              -- value moved here\n 4 |\n 5 |     println!("{}", s1);\n   |                    ^^ value borrowed here after move\n')),(0,r.kt)("p",null,"If you're coming from some other language, and you try to just pass values around and hope for the best, you're going to see this error a lot. In this example, we create a variable ",(0,r.kt)("inlineCode",{parentName:"p"},"s1"),", which owns the String. In most other languages, when we do ",(0,r.kt)("inlineCode",{parentName:"p"},"let s2 = s1;"),", we'd now have two variables that point to the same underlying object, but not so in Rust. In Rust, we ",(0,r.kt)("em",{parentName:"p"},"move")," ownership of the value from s1 to s2, so s1 stops being valid and can't be used from that point forwards. This is exactly the same as when we returned a variable in the example above."),(0,r.kt)("p",null,"If you think about this at the memory level, when we create ",(0,r.kt)("inlineCode",{parentName:"p"},"s1"),", we allocate some memory on the heap. When we say ",(0,r.kt)("inlineCode",{parentName:"p"},"let s2 = s1;"),", we're not allocating any new memory on the heap - s1 and s2 would have to point to the same memory. When we reach the end of the function, let's say we returned s2 but not s1. If s1 and s2 both owned this data, then here s1 would go out of scope so we should drop the underlying String, but s2 points to that same memory so we can't. Rust's answer to this problem is to never let this happen - only one owner at a time."),(0,r.kt)("p",null,"If we wanted to deep-copy the data in the String, we could use the ",(0,r.kt)("inlineCode",{parentName:"p"},"clone")," method to allocate more memory on the heap:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'fn strings() {\n    let s1 = String::from("hello");\n    let s2 = s1.clone();\n\n    println!("{}", s1);\n}\n')),(0,r.kt)("p",null,"Also we can use a move to redeclare an immutable variable as mutable:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n    let x = String::from("hello world");\n    let mut y = x;\n}\n')),(0,r.kt)("p",null,"When ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," takes ownership of ",(0,r.kt)("inlineCode",{parentName:"p"},"x"),", it owns that memory now and can do what it wants with it, so it's perfectly acceptable to redeclare the variable as ",(0,r.kt)("inlineCode",{parentName:"p"},"mut"),"."),(0,r.kt)("h3",{id:"stack-only-data-copy"},"Stack-Only Data: Copy"),(0,r.kt)("p",null,"Like in Java or JavaScript or C or... actually most other languages, Rust has special handling for basic data types:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'fn integers() {\n    let i1 = 1;\n    let i2 = i1;\n\n    println!("{}", i1);\n}\n')),(0,r.kt)("p",null,"This looks just like the string example above, but it compiles. This is because here ",(0,r.kt)("inlineCode",{parentName:"p"},"i1")," is an i32, which takes up four bytes of memory. Since Rust knows this at compile time, it can allocate it on the stack, and making a copy of a four byte value on the stack to another four bytes of the stack is so cheap it is essentially free. So here, ",(0,r.kt)("inlineCode",{parentName:"p"},"let i2 = i1;")," doesn't move anything, it just makes a copy of the variable for you."),(0,r.kt)("p",null,"What types get copied like this? Any type that has the ",(0,r.kt)("inlineCode",{parentName:"p"},"Copy")," trait (see ",(0,r.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch10/ch10-01-generic-data-types",title:"Chapter 10: Generic Types, Traits, and Lifetimes"},"chapter 10")," for more information about traits). In general this is any basic type (integers, booleans, chars, etc...) and any tuple made up of basic types. You can also implement it on your own data structures if they are made entirely of copyable types, or get Rust to ",(0,r.kt)("em",{parentName:"p"},"derive")," it for you, which means Rust will generate this code:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"#[derive(Copy, Clone)]\npub struct MyStruct {\n    pub foo: i32,\n}\n")),(0,r.kt)("h3",{id:"ownership-and-functions"},"Ownership and Functions"),(0,r.kt)("p",null,"We already saw that if you return a variable, then ownership of the variable is moved to the caller. We also move ownership when we pass a variable to a function:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n    let s = String::from("hello");\n    takes_ownership(s);\n\n    // Ownership of `s` was moved to `takes_ownership`\'s\n    // `some_string`, so s is no longer valid here.\n}\n\nfn takes_ownership(some_string: String) {\n    println!("{}", some_string);\n} // Here, some_string goes out of scope and `drop`\n  // is called. The backing memory is freed.\n')),(0,r.kt)("h2",{id:"42---references-and-borrowing"},"4.2 - References and Borrowing"),(0,r.kt)("p",null,'If you wanted to pass a variable to a function, but also keep it usable afterwards, you could pass the variable to the function and then return it from the function. This would move the variable into the function, and then move it back so you can keep using it. As you can imagine, passing a variable to a function and keeping it usable is something we want to do pretty often, and if this was "the way" to do it, then Rust would be a very annoying language to work in. Instead we can let the function we call ',(0,r.kt)("em",{parentName:"p"},"borrow")," the variable by passing a reference:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n    let s1 = String::from("hello");\n\n    let len = calculate_length(&s1);\n\n    println!("The length of \'{}\' is {}.", s1, len);\n}\n\nfn calculate_length(s: &String) -> usize {\n    s.len()\n}\n')),(0,r.kt)("p",null,"Two things to note here - when we call ",(0,r.kt)("inlineCode",{parentName:"p"},"calculate_length"),", instead of passing ",(0,r.kt)("inlineCode",{parentName:"p"},"s1"),", we're passing ",(0,r.kt)("inlineCode",{parentName:"p"},"&s1"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"calculate_length")," takes a ",(0,r.kt)("inlineCode",{parentName:"p"},"&String")," instead of a ",(0,r.kt)("inlineCode",{parentName:"p"},"String"),'. What we\'re passing here is a "reference to a string". Essentially ',(0,r.kt)("inlineCode",{parentName:"p"},"&s1")," contains a pointer to the String held in ",(0,r.kt)("inlineCode",{parentName:"p"},"s1"),", so we're passing that pointer to ",(0,r.kt)("inlineCode",{parentName:"p"},"calculate_length"),". ",(0,r.kt)("inlineCode",{parentName:"p"},"calculate_length")," doesn't take ownership of the ",(0,r.kt)("inlineCode",{parentName:"p"},"String"),", it merely borrows it, so the ",(0,r.kt)("inlineCode",{parentName:"p"},"String")," won't be dropped when ",(0,r.kt)("inlineCode",{parentName:"p"},"s")," goes out of scope."),(0,r.kt)("h3",{id:"mutable-references"},"Mutable References"),(0,r.kt)("p",null,"As with variables, we can have both immutable references (the default) and mutable references:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n    let mut s = String::from("hello");\n\n    change(&mut s);\n}\n\nfn change(some_string: &mut String) {\n    some_string.push_str(", world");\n}\n')),(0,r.kt)("p",null,"Mutable references come with a restriction: if you have a mutable reference to a value, you can have no other references to that value."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'let mut s = String::from("hello");\n\nlet r1 = &mut s;\nlet r2 = &mut s; // This is an error!\n\nprintln!("{}, {}", r1, r2);\n')),(0,r.kt)("p",null,"This restriction is imposed because it prevents data races.  The compiler will stop us from creating data races in multi-threaded code at compile time!"),(0,r.kt)("p",null,"The scope of a reference lasts only until it's last use, not until the end of the block, so this is fine:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'let mut s = String::from("hello");\n\nlet r1 = &mut s;\nprintln!("{}", r1);\n\nlet r2 = &mut s; // r1 is now out-of-scope, so we can create r2.\nprintln!("{}", r2);\n')),(0,r.kt)("h2",{id:"dereferencing"},"Dereferencing"),(0,r.kt)("p",null,"Rust has a ",(0,r.kt)("inlineCode",{parentName:"p"},"*")," operator for dereferencing, very similar to C++ or Go:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"let num1 = 7;\nlet num2 = &num1; // num2 has type &i32\nlet num3 = *num2; // num3 has type i32.\n")),(0,r.kt)("h3",{id:"dangling-references"},"Dangling References"),(0,r.kt)("p",null,"You can't return a reference to an object that will be dropped:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'fn dangle() -> &String {\n    let s = String::from("hello");\n    &s // This is an error.\n}\n')),(0,r.kt)("p",null,"Here ",(0,r.kt)("inlineCode",{parentName:"p"},"s")," goes out of scope at the end of the function, so the String will be dropped. That means if Rust let us return a reference to the String, it would be a reference to memory that had already been reclaimed."),(0,r.kt)("p",null,"There's no ",(0,r.kt)("inlineCode",{parentName:"p"},"null")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"nil")," in Rust. You can't have a nil reference like you could in Go."),(0,r.kt)("h3",{id:"the-rules-of-references"},"The Rules of References"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"At any given time, you can have ",(0,r.kt)("em",{parentName:"li"},"either")," one mutable reference ",(0,r.kt)("em",{parentName:"li"},"or")," any number of immutable references."),(0,r.kt)("li",{parentName:"ul"},"References must always be valid.")),(0,r.kt)("h2",{id:"43---the-slice-type"},"4.3 - The Slice Type"),(0,r.kt)("p",null,"A ",(0,r.kt)("em",{parentName:"p"},"slice")," is a reference to a contiguous sequence of elements in a collection. Slices are references so they don't take ownership. The type of a string slice is ",(0,r.kt)("inlineCode",{parentName:"p"},"&str"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'let s = String::from("hello world");\n\nlet hello = &s[0..5]; // Type of `hello` is `&str`.\nlet world = &s[6..11];\n')),(0,r.kt)("p",null,"The range syntax is ",(0,r.kt)("inlineCode",{parentName:"p"},"[inclusive..exclusive]"),". Or, in other words ",(0,r.kt)("inlineCode",{parentName:"p"},"[0..5]")," includes the 0th character in the string, but omits the fifth. With the range syntax, you can omit the first number to start at 0, and omit the second number to end at the length of the string."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'let s = String::from("rust time");\n\nlet rust = &s[..4];\nlet time = &s[5..];\nlet rust_time = &s[..];\n')),(0,r.kt)("p",null,"Slices must occur at valid UTF-8 character boundaries. If you attempt to create a string slice in the middle of a multibyte character, your program will exit with an error. See ",(0,r.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch08-common-collections",title:"Chapter 8: Common Collections"},"chapter 8")," for more details."),(0,r.kt)("p",null,"Note that if you have a string slice, this counts as a reference, so you can't also have a mutable reference to that String:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'fn first_word(s: &String) -> &str {\n    let bytes = s.as_bytes();\n\n    for (i, &item) in bytes.iter().enumerate() {\n        if item == b\' \' {\n            return &s[0..i];\n        }\n    }\n\n    &s[..]\n}\n\nfn main() {\n    let mut s = String::from("hello world");\n\n    let word = first_word(&s);\n\n    s.clear(); // error!\n\n    println!("the first word is: {}", word);\n}\n')),(0,r.kt)("p",null,"Inside main(), ",(0,r.kt)("inlineCode",{parentName:"p"},"word")," is a String slice from the String, and therefore a reference to the memory the String uses. The call to ",(0,r.kt)("inlineCode",{parentName:"p"},"s.clear()")," will fail to compile because to clear the string, we'd need to mutate it (",(0,r.kt)("inlineCode",{parentName:"p"},"clear")," is a method with a mutable reference to ",(0,r.kt)("inlineCode",{parentName:"p"},"self"),"). Since we can't create a mutable reference while ",(0,r.kt)("inlineCode",{parentName:"p"},"word")," is in scope, this fails to compile."),(0,r.kt)("h3",{id:"string-literals-as-slices"},"String Literals as Slices"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'let s = "Hello, world!";\n')),(0,r.kt)("p",null,"The type of ",(0,r.kt)("inlineCode",{parentName:"p"},"s")," here is ",(0,r.kt)("inlineCode",{parentName:"p"},"&str"),": it's a slice pointing to where this string is stored in the binary."),(0,r.kt)("h3",{id:"string-slices-as-parameters"},"String Slices as Parameters"),(0,r.kt)("p",null,"These two function signatures are very similar:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"fn first_word_string(s: &String) -> &str {...}\n\nfn first_word_str(s: &str) -> &str {...}\n")),(0,r.kt)("p",null,"The first takes a reference to a String, the second takes a string slice. The second one, though, is generally preferred. It's trivial to convert a string to a slice, so you can call the second with any String, string slice, or string literal, or even a reference to a String (see ",(0,r.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch15-smart-pointers",title:"Chapter 15: Smart Pointers"},"chapter 15")," for more on type coercion)."),(0,r.kt)("p",null,"In the reverse directory, it's a bit tedious to convert a string slice into a String so the first version, ",(0,r.kt)("inlineCode",{parentName:"p"},"first_word_string"),", is much less flexible."),(0,r.kt)("h3",{id:"other-slices"},"Other Slices"),(0,r.kt)("p",null,"Much like in Go, we can also create slices from arrays:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"let a = [1, 2, 3, 4, 5];\n\nlet slice = &a[1..3];\n\nassert_eq!(slice, &[2, 3]);\n")),(0,r.kt)("p",null,"The type of ",(0,r.kt)("inlineCode",{parentName:"p"},"slice")," here is ",(0,r.kt)("inlineCode",{parentName:"p"},"&[i32]"),"."),(0,r.kt)("p",null,"Continue to ",(0,r.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch05-structs",title:"Chapter 5: Using Structs to Structure Related Data"},"chapter 5"),"."))}h.isMDXComponent=!0}}]);